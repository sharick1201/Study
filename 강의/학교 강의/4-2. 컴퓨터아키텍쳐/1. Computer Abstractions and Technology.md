3/7(금)
* 복습 3/13(목)


#### The Computer Revolution
<font color="#a5a5a5">20C 중반부터 시작</font>
* Progress in computer tech
	* 특정 산업에 특화된(domain-specific) accelerators<font color="#a5a5a5">(ex.GPU)</font>이 기반이 됨
* Makes novel application feasible
* Computers are pervasive

#### Classes of Computers
1. Personal computers(PC)
2. Sever Computers
3. SuperComputers
4. Embedded computers



#### We Are in The PostPC Era
* PMD
* Cloud computing
	* WSC
	* SaaS



#### What You Will Learn
* How programs are translated into the machine language
	* and how the hardware excutes them
* The hardware/software interface
* <font color="#c0504d">What determines program performance</font>
	* <font color="#c0504d">And how it can be improved</font>
* How hardware designers improve performance
* What is parallel processing(병렬 컴퓨팅)



#### Performance(성능) 이해하기
* Algorithm
	* Determines <u>number of operations</u> excuted
* Programming language, compiler, architecture
	* <font color="#a5a5a5">컴파일러는 프로그래밍 언어로 작성된 코드를 기계어로 변환한다.</font>
		* <font color="#9bbb59">컴파일러에 대해 좀 자세히 공부해보고 싶다: </font>[[컴퓨터의 구성 요소]]
	* <font color="#a5a5a5">아키텍처는 하드웨어 구조를 정의한다.</font>
	* Determine <u>number of machine instructions</u> excuted per operation
* Processor and memory system
	* <font color="#a5a5a5">프로세서는 기계 명령어를 실행하는 하드웨어 부품이다.</font>
	* Determine <u>how fast instructions are excuted</u>
* I/O system (including OS)
	* <font color="#a5a5a5">I/O 시스템은 입출력 작업을 관리한다.</font>
	* <font color="#a5a5a5">운영체제는 I/O 작업을 제어하고 최적화한다.</font>
	* Determines <u>how fast I/O operations are excuted</u>


#### Seven Great Ideas
1. Use <u>abstraction</u> to simplify design
	* <font color="#8064a2">다양한 수준의 추상화 사용하여, 낮은 수준의 세부사항은 숨기고 상위 수준에서 더 단순한 모델을 제공</font>
2. Make the <u>common case fast</u>
	* <font color="#8064a2">잘 안쓰이는 걸 최적화하는 것보다 더 효과적이고, 보통 자주 쓰이는 건 더 단순하기 때문에 난이도도 낮다!</font>
	* <font color="#8064a2">일반적인 게 무엇인지를 잘 알고 있어야 한다는 의미이다. by 주의 깊은 실험과 측정</font>
3. Performance via <u>parallelism</u>
4. Performance via <u>pipelining</u>
	* <font color="#8064a2">pipelining: parallelism에 해당하는 패턴 중 하나</font>
		* <font color="#8064a2">산불이 났을 때 물이 든 양동이를 여럿이서 건네주는 것과 같다.</font>
		* <font color="#a5a5a5">명령어 실행을 여러 단계로 나누어 각 단계를 동시에 수행함으로써 CPU 성능을 극대화하는 방법</font>
5. Performance via <u>prediction</u>
	* <font color="#8064a2">경우에 따라 확실하게 알 때까지 기다리는 것보다, 추측하고 작업을 시작하는 것이 평균적으로 더 빠를 수 있다.</font>
	* <font color="#8064a2">단, 잘못된 예측을 한 경우 복구하는 메커니즘이 너무 비싸지 않고, 예측의 정확도가 상대적으로 높다는 전제가 필요</font>
6. <u>Hierarchy</u> of memories
	* <font color="#8064a2">메모리는 빠르고, 용량이 크고, 저렴한 게 좋다.</font>
		* <font color="#8064a2">빠를수록 성능이 좋아지고, 용량이 클수록 해결할 수 있는 문제의 크기도 커지고, 메모리 비용이 전체 컴퓨터 비용의 대부분을 차지한다.</font>
		* <font color="#8064a2">빠름, 큰 용량, 저렴함은 서로 상충된다.</font>
	* <font color="#8064a2">이런 상충을 메모리 계층 구조로 해결하였다.</font>
		* <font color="#8064a2">빠르고, 용량이 작고, 비싼 메모리는 상위 계층 / 느리고, 용량이 크고, 저렴한 메모리는 하위 계층</font>
			* <font color="#9bbb59">용량이 큰데 어떻게 저렴할 수가 있지? 클수록 비싸야하는 거 아닌가?</font>
				* <font color="#a5a5a5">메모리 설계 시 속도와 용량은 서로 상충되는 요소이다.</font>
				* <font color="#a5a5a5">메모리는 고속 메모리(SRAM, DRAM...)와 저속 메모리(HDD, SSD...)로 나뉜다.</font>
				* <font color="#a5a5a5">고속 메모리는 공정이 복잡해서 용량 키우기가 어렵고, 셀 크기가 작아 집적도는 높지만 용량 키우기에는 한계가 있다.</font>
				* <font color="#a5a5a5">저속 메모리는 공정이 단순해서 용량 키우기가 쉽고, 셀 크기도 크게 가져갈 수 있어서 용량 키우기가 쉽다.</font>
				* <font color="#a5a5a5">따라서 보통 고속 메모리는 속도에 초점을 맞추고, 저속 메모리는 용량에 초점을 맞춘다.</font>
				* <font color="#a5a5a5">셀 크기: 메모리 소자를 구성하는 최소 단위의 크기. 하나의 메모리 셀은 1비트의 데이터를 저장할 수 있는 가장 기본적인 단위.</font>
		* <font color="#8064a2">캐시를 통해 메인 메모리가 상위 계층만큼 빠르고, 하위 계층만큼 크고 저렴한 것처럼 보이게 만들 수 있다. (5장에서 더 배운다.)</font>
7. <u>Dependability</u> via redundancy
	* 컴퓨터는 빠를 뿐만 아니라, 믿을만해야 한다.
	* 물리적 장치는 언제든 고장날 수 있기 때문에, 고장을 감지할 수 있는 기능과 고장이 발생했을 때 대체 가능한 중복 구성 요소를 마련해두어야 한다. 이를 통해 시스템의 신뢰성을 높인다.

<font color="#8064a2">+Moore's Law</font>


#### Below Your Program
* Application software
	* written in high-level language
* System software
	* 
	* 현대의 메이저한 시스템 소프트웨어 두 종류:
		* OS
			* 기본적인 입출력 기능 처리
			* 메모리와 스토리지 관리
			* 자원을 share하고 tasks를 스케줄링
				* <font color="#a5a5a5">스케줄링: CPU를 사용하려고 하는 특정 작업이나 프로세스를 정해진 시간이나 순서에 따라 수행하도록 계획하는 과정</font>
					* <font color="#a5a5a5">다양한 알고리즘이 있다.</font>
					* <font color="#a5a5a5">FCFS: 도착 순으로</font>
					* <font color="#a5a5a5">SJF: 실행 시간이 가장 짧은 것부터</font>
					* <font color="#a5a5a5">RR: 우선순위 없이 각각 일정시간만 사용, 번갈아가면서 사용</font>
					* https://jwprogramming.tistory.com/17
		* Compiler
			* HLL code를 machine code로 변환
* Hardware
	* Processor
	* Memory
	* I/O controllers

---


3/12(수)
첫 번째 코드: $Θ(n^2)$: two comparison(one is in the another)
두 번째 코드: $Θ(n)$: one comparison

첫 번째 코드에는 약간 개선의 여지가 있다.
```java
// input: a[0] ... a[n-1]
// output: min


for (i = 0; i < n; i++) {

	isMin true;

	for (j = 0; j < n; j++) {

		// 여기서! 이미 isMin = false가 되었다면 굳이 나머지 a[i]랑 비교할 필요가 없다. 따라서 break;를 추가할 수 있다.
		if (a[j] < a[i]) {
		isMin = false
		break;
		}
	}
	
	if (isMin) min = a[i];
}
```

Running time may depend on the contens of the input, not just its size!
실행시간은 데이터의 양 뿐만 아니라 데이터의 내용에 따라서도 크게 영향을 미친다.
* ex) 첫 번째 코드에 0, 1, 1, 1, 1 ... 1 이 들어가는 경우


Usually we focus on the worst case

우리가 성능을 측정할 때, 데이터 내용은 고려하지 않는다는 가정을 염두에 두고 있자.

즉, Worst-case time complexity 를 계산하고 있는 것. 가장 위의 코드 실행 시간 계산도 Worst-case time complexity인 것이다.

이번 수업 내용을 기반으로 한 학기 내내 적용하는 것.


Another Example)
First, we are given an array of integers a[0], ... a[n-1]
Later, queries (x,y) come, and we are to answer a[x]+a[x+1]+...+a[y]

Suppose q queries come

```java
// preprocessing: do nothing

// query (x,y) comes

answer = 0;
for (i=x;i<=y;i++) {
	answer += a[i];
}
```
$Θ(qn)$

```java
// preprocessing
for (i = 0; i < n; i++) {
	sum[i][i] = a[i]
	for (j=i+1; j<n; j++){
		sum[i][j] = sum[i][j-1] + a[j]
	}
}

// now query comes
answer = sum[x][y]
```
$Θ(n^2+q)$

Which is efficient?
여전히 q와 n의 값을 모르니 확신할 수 없다.
n=10 q=10<sup>9</sup> 이라면 2번이 효율적
n=10<sup>9</sup>  q=10 이라면 1번이 효율적
n=10<sup>9</sup>  q=10<sup>9</sup> 이라면... 1을 강제적으로 선택하게 될 것이다. 2가 더 빠르더라도, 사양이 부족하기 때문.


Space complexity as a function of n and q 
이때는 Worst-case time complexity을 기반으로 측정한다.
첫 번째 코드 $Θ(1)$
두 번째 코드$Θ(n^2)$
이런 극단적인 케이스도 있다. 그러나 강의에서는 대부분 이런 공간 복잡도는 고려되지 않는다.

We often focus on the worst time complexity




세번째 코드
```java
// preprocessing
sum[0]= a[0];
for (i = 1; i < n) {

}



// now query comes

```
time: $Θ(n+q)$
space: $Θ(n)$

이 코드의 단점: 이게 만약 integer가 들어가는 게 아니고 string이라면 unreliable하다 (즉 전체 프로그램의 기능과 요구사항들을 고려하는 게 중요하다.)

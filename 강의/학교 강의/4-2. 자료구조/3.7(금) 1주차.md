What is computer? -> What do/can you do with a computer?
	ex. web search, calculation, coding, playing videos, playing games ...

공통점 of all of them: Computers store and process information.

computers store, <u>communicate(전달/통신)</u>, and process information!

in this course, we will learn about storage and process of information.


example)
- medical records 의료기록
	- Storage
		- in folders, on preprinted forms
	- Processing
		- what do we need to do?
			- retrieve(검색) a patient's record
			- modify its contents (이건 의사가 하는거고 우린 알 수 없으니 신경쓰지 말자)
			- return it to the storage
		- 이거.. 어케햇슴?
			- 알파벳순으로 정렬
			- 방문날짜로 정렬
			- revisit 고려
			- color coding
		* 즉... criteria를 정해두고 그것에 따라 order할 것이다.
		- 컴퓨터가 없어도, 많은 정보를 저장한다면 자연스러운 접근이다.

Bottom Line(핵심 요약)
* Data organization in storage affects processing efficiency
* How computers store and process information differs from how humans do
	* 컬러 코딩은 사람에겐 매우 효율적이지만, 컴퓨터에게는 비효율적이다.


### Measuring Program Efficiency
#### How to measure program efficiency
ex. 최솟값 구하기
1. for문 2개
```java
// input: a[0] ... a[n-1]
// output: min


for (i = 0; i < n; i++) {

	isMin true;

	// a의 모든 값을 하나씩 확인한다.
	for (j = 0; j < n; j++) {
		// a[i]이랑 a의 모든 값이랑 하나씩 비교한다.
		// a[j]가 a[i]보다 작다면, isMin 변수를 false로 설정한다. a[i]가 최소값이 아니라는 것을 의미한다.
		if (a[j] < a[i]) isMin = false
	}
	
	if (isMin) min = a[i];
}
```

2. for문 1개
	```java
// input: a[0] ... a[n-1]
// output: min

// a[0]이 최솟값이라 가정하고 시작하자.
min = a[0];
for (i = 1; i < n; i++) {
	// a[i]이 지금까지 발견된 최소값(현재 min)보다 작은지 확인하고, min보다 작으면 min의 값을 a[i]로 바꾼다.
	if (a[i] < min) min = a[i];
} 
```

2가 시간도 더 적게 들고, 코드도 더 짧고, memory space가 덜 든다(사용하는 변수 수가 더 적음)
그러나 1이 완전 쓸모 없는 코드냐? 그건 아니다. 복잡한 알고리즘에서는 이게 더 효율적이고 명확할 수도 있다.

기술이 발전하면서 memory가 가장 scarest한 resource는 아니게 되었다. 요즘은 시간이 가장 중요하다.


Two ways fo answering the question
1. Empirically
	1. measure the running time for different sets of data
2. Analytically
	1. Write the running time as a formula in terms of the input size
Let's use the latter approach(2)

1의 경우
n add
n+1 compare    (i: 0 -> n)

n add                                                    x n
n+1 compare    (j: 0 -> n)                   x n
n compare        (j: 0 ~ n-1)                 x n

=> 3n^2 + 3n + 1 ns


2의 경우
(n-1) add
n comp
(n-1) comp
=> 3n-2 ns

How meaningful is it to be this precise?
-> Different platforms
-> 


##### Order of growth
Lets treat 2n and 3n "equally"    <span style="background:rgba(240, 107, 5, 0.2)"> 왜??? 글고 O 는 무슨 뜻이지 </span>
If f(n) can be bounded by g(n) from above after multiplying the latter by and approximate constant, we say f(n) = O(g(n))

ex.
	p(n) = 2n
	g(n) = 3n
	p(n)=O(g(n))
	g(n)=O(p(n))

2n = O(n), 3n = O(n)
.01n^2 =? O(n)    ->    NO!
.01n^2 + 100n = O(n^2), not O(n)


Formally, PPT 참고 할 것 

n  = O(n^2)


빅오, 빅오메가,  이거를 asymptotic(점근적) notation 이라고 부른다.


----
#### 뱀발

읭?마지막페이지 반드시 연습해서 익숙해질 것.

---
#### 복습 3/11(화)
* 컴퓨터로 하는 앵간한 task들은 정보를 저장하고, 전달/통신하고, 처리하는 일이다.
* 이 수업에서는 정보를 저장하고 처리하는 것에 대해 배울 것이다.

* 핵심
	* 데이터 저장 방식은 성능에 영향을 미친다.
	* 컴퓨터와 사람의 정보 처리 방식은 다르다.

* 이번 시간에는 <u>프로그램 성능 측정법</u>에 대해 배울 것이다.
* 




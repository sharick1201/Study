이미 값이 특정 storage에 할당되었다면, 그 storage에 저장된 내용을 바꿀 수는 없다.
a ="3"
a=b
⇒ a = 3, b = 3

a="4"
⇒ a = 4, b = 3


#### Arrays
case 1: of integers
a = new int[10];
a[3] = 4;
b = a;


case 2: of MyInt (array of references, not instances)
c = new MyInt[10];

#### File I/O
there's no delete

자바에서는 빌트인 자료구조를 많이 제공하고 있지만, 우리는 그걸 사용하지 않고 직접 만들어 사용할 것이다. (어떻게 사용하는지도 중요하지만 이 수업에선 어떻게 만드는지가 중요하기 때문에)

## Array
#### The array is a data structure
* set of "homogeneous" data
* indexed by consecutive integers
	* ranging from 0 to n-1
* O(1) time 
* <font color="#c0504d">Size n needs to be specified at the time of creation</font>

#### A homebrew array
* 직접 만들어보자

* How much does it takes to access the k-th element?
	1. O(1): ?? 면에서, 이것도맞음
	2. O(k) : k번째까지 비교해야 하기 때문에 이렇게 대답한 거라면 이것도 맞음
	3. Your question is ill-posed: java 내장 Array타입은 ?? 어쩌고


#### Binary Search
array = [0,1]이고 찾는 게 0이라면, 무한루프에 빠진다.

이런 미묘한 에러들을 찾는 게 중요하다.

if left == right && 는 왜 필요한가?
* n이 0이라면?
	* 의도대로라면 excuted되지 않는 게 좋다
	* 그러나 이게 없으면 돌아가고, ...??

What is the time complexity? $Θ(logn)$

#### Sequential search (linear search)
it' trivial

* Searches from a[0] to a[n-1], one by one
* What is the time complexity? $Θ(n)$ (linear time)

#### Sorted Array
* But we have to maintain the array sorted
* Insertion
	* 중간에 값을 넣으려면, 추가하는 값보다 큰 애들을 한 칸씩 뒤로 넘겨야한다.
	* 삭제도 마찬가지이다. 이건 한 칸씩 앞으로 땡겨야 되겠다.
	* What is the time complexity? $Θ(n)$
		* 최악의 경우는 가장 작은 수를 추가하거나, 존재하는 가장 작은 수를 삭제하는 경우 

* Unsorted array
	* O(n) search
	* O(1) addition
		* 특정 위치에 넣고싶으면 그 위치에 넣고, 기존에 있던 걸 젤 뒤로 swap 하면 됨
		* 그냥 제일 뒤에 넣어도 되고
	* O(1) deletion

* Sorted array


#### Binary Search
중간에 값을 넣으려면 추가하는 값보다 큰 애들을 한 칸씩 뒤로 넘겨야 할 뿐만 아니라, 처음에 추가하는 값이 어느 위치에 들어가야 하는지도 찾아야 한다.




## Linked Lists
#### Arrays
* Usally implemented with a contiguous block in memory 
	* given index가 있는건 꽤 좋은 장점이다.

#### Linked list
* What if we use noncontiguous blocks?
* How can we locate all the elements? (if we add something?)

* Each element constitutes a "node*

* time complexity
	* O(n) access
		* next에 적혀있는 다음 데이터 위치 따라 찾아가야 하기 때문
	* O(1) addition
		* 새로운 객체를 만들고 다음 데이터 위치만 수정해주면 된다
	* O(1) deletion

<font color="#9bbb59">이건 저장위치가 연결되어 있지 않으니까 다음 걸 찾아가는데 시간이 좀 더 걸리지 않을까? 자동으로 다음 걸 찾아가는거랑, 어디 있는지 확인하고 거길 찾아가는건 차이가 있을 거 같다.</font>


(이 강의에는... OOP principle가 무시된 코드를 보여줄 것이다.(그게 이 강의의 중요한 부분은 아니기 때문) 그치만 여러분은 지키시라...)



첫 노드 추가
처음에는 first 라는 노드만 존재한다. 여기서 하나를 추가하면,
InsertAtFront 내의 순서대로 돌아가게 된다.
즉, 새 노드를 만들고, 그 안에 데이터는 x로 선언하고, next는 first의값&위치(즉, null) 를 점하게 된다.


첫 노드 삭제
더 이상 reference되지 않는, 즉 기능적으로 삭제된 node는 자동적으로 삭제될 것이다<font color="#9bbb59">(garbage collector를 통해??)</font>

DisplayAll
* 공식적으로 소개하진 않을거다(시험에 안낼거다) terrible design이기 때문에..........(ㅋㅋㅠㅠ)
* 소개만 시켜주겟다...


첫 노드 이외의 추가

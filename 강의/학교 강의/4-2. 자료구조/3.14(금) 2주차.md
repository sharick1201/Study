이미 값이 특정 storage에 할당되었다면, 그 storage에 저장된 내용을 바꿀 수는 없다.
a ="3"
a=b
⇒ a = 3, b = 3

a="4"
⇒ a = 4, b = 3


#### Arrays
case 1: of integers
a = new int[10];
a[3] = 4;
b = a;


case 2: of MyInt (array of references, not instances)
c = new MyInt[10];

#### File I/O
there's no delete

자바에서는 빌트인 자료구조를 많이 제공하고 있지만, 우리는 그걸 사용하지 않고 직접 만들어 사용할 것이다. (어떻게 사용하는지도 중요하지만 이 수업에선 어떻게 만드는지가 중요하기 때문에)

## Array
#### The array is a data structure
* set of "homogeneous" data
* indexed by consecutive integers
	* ranging from 0 to n-1
* O(1) time 
* <font color="#c0504d">Size n needs to be specified at the time of creation</font>

#### A homebrew array
* 직접 만들어보자

* How much does it takes to access the k-th element?
	1. O(1): ?? 면에서, 이것도맞음
	2. O(k) : k번째까지 비교해야 하기 때문에 이렇게 대답한 거라면 이것도 맞음
	3. Your question is ill-posed: java 내장 Array타입은 ?? 어쩌고


#### Binary Search
array = [0,1]이고 찾는 게 0이라면, 무한루프에 빠진다.

이런 미묘한 에러들을 찾는 게 중요하다.

if left == right && 는 왜 필요한가?
* n이 0이라면?
	* 의도대로라면 excuted되지 않는 게 좋다
	* 그러나 이게 없으면 돌아가고, ...??

What is the time complexity? $Θ(logn)$

#### Sequential search (linear search)
it' trivial

* Searches from a[0] to a[n-1], one by one
* What is the time complexity? $Θ(n)$ (linear time)

#### Sorted Array
* But we have to maintain the array sorted
* Insertion
	* 중간에 값을 넣으려면, 추가하는 값보다 큰 애들을 한 칸씩 뒤로 넘겨야한다.
	* 삭제도 마찬가지이다. 이건 한 칸씩 앞으로 땡겨야 되겠다.
	* What is the time complexity? $Θ(n)$
		* 최악의 경우는 가장 작은 수를 추가하거나, 존재하는 가장 작은 수를 삭제하는 경우 

* Unsorted array
	* O(n) search
	* O(1) addition
		* 특정 위치에 넣고싶으면 그 위치에 넣고, 기존에 있던 걸 젤 뒤로 swap 하면 됨
		* 그냥 제일 뒤에 넣어도 되고
	* O(1) deletion

* Sorted array


#### Binary Search
중간에 값을 넣으려면 추가하는 값보다 큰 애들을 한 칸씩 뒤로 넘겨야 할 뿐만 아니라, 처음에 추가하는 값이 어느 위치에 들어가야 하는지도 찾아야 한다.




## Linked Lists
#### Arrays
* Usally implemented with a contiguous block in memory
	* given index가 있는건 꽤 좋은 장점이다.

#### Linked list
* What if we use noncontiguous blocks?
* How can we locate all the elements? (if we add something?)

* Each element constitutes a "node*
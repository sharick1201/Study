3/12(수) 2주차 대면 강의



순차탐색

#### 2. 임의의 숫자 찾기

알고리즘 1: 
최대 숫자 찾기처럼 머릿속에 85를 기억하고 바닥에 펼쳐진 카드를 차례대로 한 장씩 읽으며 85가 적힌 카드를 찾는다.

근데 더 효율적으로 할 수는 없을까?

알고리즘 2:
오름차순으로 정렬되어 있다면?
8장의 카드를 읽은 후에나 85를 찾는다.

알고리즘 3:
순차탐색보다 더 효율적인 방법은 없을까?
* 즉, 카드가 정렬되어 있다는 정보를 어떻게 활용할 수 있을까?

중간에 있는 카드인 45(혹은 55)와 85를 먼저 비교한다.
중간 카드 한 장을 읽어 85와 비교해보는 것이, 첫 카드부터 읽어나가는 순차탐색보다 훨씬 빠르게 목표(85가 적힌 카드)에 다가감을 알 수 있다.

이것이 바로 이진탐색! (Binary Search)
* 오름차순으로 정렬된 데이터를 반으로 나누고,
* 나누어진 반을 다시 반으로 나누고,
* 이 과정을 반복하여 원하는 데이터를 찾는 탐색 알고리즘

#### 3. 동전 거스름돈
최소 동전의 수 6
<font color="#a5a5a5">거스름돈을 큰 값의 동전부터 나누어 그 몫을 취한다.</font>

주어진 거스름돈에 대해 어떻게 하면 가장 적은 수의 동전을 찾을까?
* 일반적으로 거스름돈에 대해서 가장 큰 액면의 동전부터 차례로 고려한다.

730원의 거스름돈에 대해서
* 500원짜리 동전 1개를 선택
* 남은 230원에 대해 100원짜리 동전 2개 선택
* 남은 30원에 대해 10원짜리 동전 3개를 선택한다.

동전 거스름돈 문제를 해결하는 알고리즘: 그리디(Greedy) 알고리즘
* <font color="#a5a5a5">내가 취할 수 있는 가장 유리한 선택을 반복적으로, 끝까지 취해나가는 방식</font>

#### 4. 가짜 동전 찾기
알고리즘 1:
임의의 동전 1개를 저울 왼편에 올리고, 나머지 동전을 하나씩 오른편에 올려서 가려내어 보자

이 알고리즘은 1번 ~ (n-1)번을 반복하게 될 것이다.
* 운이 좋으면 1번 만에 가짜 동전을 찾는다. (best case)
* 최악의 경우는 가장 마지막에 가짜 동전을 올려놓게 되는 경우이다. (worst case)
	* 총 동전 수가 n이라면 (n-1)번 저울을 재야 한다.


알고리즘 2:
동전을 2개씩 짝을 지어, n/2짝을 각각 저울에 달아서 가짜 동전을 찾아보자.

이 알고리즘은 1번 ~ (n/2)번 반복하게 될 것이다.
* 철수의 알고리즘에 비해 최악의 경우 저울에 다는 횟수가 거의 1/2로 줄었다.

알고리즘 3:
동전 더미를 절반으로 나누어 저울 양편에 놓으면 어떨까?
남은 동전 수는 계속 1/2로 줄어들게 되고, 나중에 2개가 남았을 때 가짜 동전을 가려낼 수 있다.

<font color="#a5a5a5">근데 나누는 중에 홀수로 나눠지면 어떡함?</font>

동전 더미를 반으로 저울에 달고, 가벼운 쪽의 더미를 계속 반으로 나누어 저울에 단다.
분할된 더미의 동전 수가 1개씩이면 마지막으로 저울을 달아 가벼운 쪽의 동전이 가짜임을 찾아낸다.
이 알고리즘은 동전이 1024개 있을 때, 10번 달아야 한다.
일반적인 n에 대해서는 log<sub>2</sub>n번 저울에 달면 가짜 동전을 찾는다.

알고리즘 3은 운이 좋을 때가 없다. 마지막에 가서야 가짜 동전을 찾기 때문이다.
* 알고리즘 2와 3 중 어떤 게 더 좋은 알고리즘인가?
	* 무조건 worst case anaylsis만 고려하느냐, 아니면 운이 좋은 경우도 고려할 것이냐는 상황에 따라 다르게 고려하면 된다.
		* <font color="#a5a5a5">구체적으로 어떤 상황들이 있는지? 실무에서는 어떻게 적용되는지?</font>

#### 5. 미로 찾기
알고리즘 1: 오른손 법칙
* 현 위치에서 한 방향을 선택하고, 벽에 오른손을 댄다.
* 그리고 출구가 나올 때까지 계속 오른소능ㄹ 벽에서 떼지 않고 계속 걸어간다.
* 이 방법은 실타래나 특별한 표시 필요 없이 항상 출구를 찾게 해준다.

⇒ 가다가 막히면 길을 다시 되돌아오는 방법: 백트래킹 기법
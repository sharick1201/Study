## 채팅 기능 기본 요구사항
채팅 서비스는 기본적으로 아래 기능을 요구한다.

1. **메세지 발신**
	* 클라이언트(사용자)가 애플리케이션을 통해 메시지를 발신한다. 이 메시지는 서버로 전송된다.
	* 서버는 클라이언트에서 수신된 메세지를 받아서 처리한다.
		
2. **수신자(recipient) 결정**
	* 서버는 메시지의 수신자를 결정한다.
		* 여기에서 말하는 수신자(recipient)란?
			* 메세지를 받을 사용자 또는 그룹
			* 수신자는 메세지의 내용에 따라 다를 수 있다.
				* 즉, 특정 사용자 ID를 기반으로 수신자를 설정하거나, 채팅룸 ID를 기반으로 수신자를 설정할 수도 있다.
3. **메세지 전달**
	* 수신자가 온라인 상태인지 확인한다.
		* 여기에서 말하는 온라인 상태란? 수신자에 해당하는 클라이언트가 서버에 연결되어 있고, 메세지를 받을 준비가 되어있는 상태
	* 수신자의 접속 상태에 따라 다음 로직이 달라진다.
		* 수신자가 온라인 상태라면, 서버는 해당 클라이언트에게 메세지를 즉시 전달한다.
		* 수신자가 오프라인 상태라면, 서버는 해당 메세지를 보관한다.
			* 이때 메세지는 수신자가 다시 온라인 상태가 될 때까지 대기한다.
			* 수신자가 온라인 상태로 돌아오면, 서버는 보관된 메세지를 해당 사용자에게 전달한다.

예컨대 사용자A가 사용자 B에게 메세지를 보낸다고 하자.
그럼 서버는 메세지를 수신하고, 수신자가 사용자 B임을 확인한다.
다음으로 서버는 사용자 B가 온라인 상태인지 오프라인 상태인지 확인한다.
온라인 상태라면, 메세지를 즉시 전달한다. 오프라인 상태라면, 사용자 B가 온라인 상태가 될 때까지 기다린다.

<span style="background:rgba(240, 107, 5, 0.2)">→ 그럼 제때제때 안 보는 사람이 많으면 많을수록 기다리는 데에 자원이 소비되고, 기능 저하가 일어나는 건가? 서버는 어떤 식으로 '대기'하는가?</span>
* [[서버는 '어떻게' 메세지를 대기시키는가?]]

## 요구사항 충족을 위한 네트워크 통신 프로토콜

상술한 채팅 기능 요구사항을 충족시키기 위하여, 채팅을 시작하고자 하는 클라이언트는 **네트워크 통신 프로토콜**을 사용하여 요청을 보낸다.

 이때, 어떤 통신 프로토콜을 사용할 것인가?

* HTTP + 롱 폴링
	* HTTP
		* 클라이언트가 연결을 만드는 단방향 프로토콜
			* 클라이언트가 요청을 보내야만 서버가 응답한다. 
			* 서버가 클라이언트에게 먼저 데이터를 전송할 수는 없다.
		* 메세지를 송신할 때는 송신자(sender)에 해당하는 클라이언트가 먼저 통신을 요청하기 때문에, 사용해볼 수는 있겠으나, 단방향 프로토콜이기 때문에 메세지를 수신받는 로직이 매우 복잡해진다.
			* 이를 해결하기 위해 폴링이나 롱 폴링 기술을 접목한다.
	* 폴링이란?
		* 클라이언트가 주기적으로 서버에게 새 메세지가 있는지 물어보는(요청하는) 기술
		* 주기적으로 요청을 보내는 것이기 때문에, 폴링을 자주 할수록 비용이 높아진다.
		* 그렇다고 요청 보내는 주기를 줄이면, 실시간성에 크게 위배된다.
		* 동기화할 필요가 없는 경우(채팅 메세지가 없을 때) 서버 자원이 불필요하게 낭비된다.
	* 롱 폴링이란?
		* 폴링의 단점을 개선하고자 나온 기법
		* 기존 폴링 방식 + 새 메세지가 있는지 물어볼 때(요청을 받았을 때),
			* 메세지가 있다면, 바로 해당 메세지를 응답으로 반환한다.
			* 메세지가 없다면, 응답을 보내지 않고 <u>대기</u>한다.
				* 대기하는 중 새 메세지가 온다면, 그 메세지를 바로 반환한다.
				* 대기는 타임아웃이 발생할 때까지 지속된다.
			* 이때, 클라이언트는 새 메세지가 반환되거나 타임아웃이 될 때까지 연결을 유지한다.
			* 그런데 서버 입장에선 클라이언트가 연결을 해제했는지 아닌지를 알 수가 없다.
		* 게다가 여전히 주기적으로 요청을 보내는 것이기 때문에, 비효율적이다.

* WebSocket
	* 클라이언트-서버 간의 양방향 실시간 통신을 지원
	* 서버가 클라이언트에게 비동기 메세지를 보낼 때 가장 널리 사용하는 기술
	* 단일 TCP 연결을 통해 초기 연결 설정 후, 양방향(Full-Duplex) 통신 가능
		* 풀어 이야기하자면, 클라이언트가 연결을 요청할 때는 HTTP 연결로 수행하고, 성공하면 Web Socket 연결로 업그레이드된다.
	* HTTP 프로토콜이 사용하는 기본 포트번호를 그대로 사용한다.

* Jabber
	* XMPP(Extensible Messageing and Presence Protocol) 기반의 메세징 기술
	* XML을 사용하여 실시간 메세지와 상태 정보를 교환한다.

* STOMP
	* 메세지 전송을 효율적으로 하기 위해 등장한 프로토콜
	* 텍스트 기반의 메세징 프로토콜
	* 주로 메시지 브로커(예: RabbitMQ, Kafka, Active MQ)와 함께 사용된다.
		* 메세지 브로커란?
			* 데이터 교환을 위해 사용되는 중간 관리 소프트웨어
			* 발신자와 수신자 사이에서 데이터를 중개한다.
			* 메세지를 수집, 임시저장, 변환, 라우팅하는 역할
			* 이를 사용하면, 시스템 간 통신이 비동기적, 독립적, 안정적으로 이루어진다.

#### 통신 프로토콜 장단점 비교

* HTTP + 롱 폴링
	* 장점
		* 구현이 간단하다.
		* 기존 HTTP 기반 기술과 호환성이 좋다.
	* 단점
		* 주기적으로 요청을 보내는 것이기 때문에, 자원 낭비가 심하다. 서버 리소스를 많이 차지한다.
		* 완전한 실시간성을 보장하지 못한다.
		* 대기 중에, 서버 입장에선 클라이언트가 연결을 해제했는지 아닌지를 알 수가 없다.
		* 라운드 로빈 알고리즘을 사용하는 경우 메세지를 보내는 클라이언트와 수신받는 클라이언트가 같은 채팅 서버에 접속하지 않을 수도 있다.
			* HTTP 서버들은 보통 무상태 서버이니, 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용한다면... 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴딩 연결을 가지고 있지 않은 서버일 수 있는 것

* WebSocket
	* 장점
		* 실시간 데이터 전송이 가능하므로 지연 시간이 최소화된다. 실시간 데이터 전송이 가능하므로 사용자 접속 상태, 사용자 입력 상태 정보도 가져올 수 있다.
		* 서버에서 클라이언트로 데이터를 줄 수 있어서 효율적이다.
		* HTTP 프로토콜이 사용하는 기본 포트번호를 그대로 사용하기 때문에, 방화벽이 있는 환경에서도 일반적으로 잘 동작한다.
	* 단점
		* HTTP에 비해, 구현이 비교적 복잡하다.
		* 채팅방마다 세션을 관리해야 해서 번거롭다.
		* 웹소켓 연결은 항시 유지되어야 하기 때문에, 연결 유지 비용이 높아 연결 관리를 효율적으로 해야 한다.
			
* Jabber
	* 장점
		* 강력한 보안(TLS/SASL)을 제공한다.
		* 다양한 어플리케이션과 호환된다.
	* 단점
		* XML 기반이라 데이터 크기가 커질 수 있고, 대규모 트래픽 처리 시 성능 저하가 일어난다.
		
* STOMP
	* 장점
		* 구현이 간단하다.
		* 다양한 언어와 플랫폼에서 지원된다.
		* 메세지 브로커와 쉽게 통합 가능하다.
		* Spring Security를 이용하여 채팅 엔드포인트의 권한을 제어할 수 있다.
		    - ex) JWT 확인을 통해 원하는 사용자만 채팅에 입장하도록 만들 수 있다.
	- 단점
		- 









----


참고자료:
* 채팅 서비스 설계 시 고려점
	통신 아키텍쳐 측면: https://guti-coding.tistory.com/182
	서버 아키텍쳐 측면: https://guti-coding.tistory.com/190?category=1266186
	
* 채팅 시스템 설계 (『가상 면접 사례로 배우는 대규모 시스템 설계 기초』 기반 포스팅)
	https://azderica.github.io/til/docs/dev/system-design-interview/ch12/
	https://velog.io/@gidskql6671/채팅-시스템-설계
	https://jaeseo0519.tistory.com/410 (책 기반 + 자세한 추가 정보도 많음!)
	
* 카카오엔터의 채팅 플랫폼 구현기
	https://kakaoentertainment-tech.tistory.com/109



* 채팅 통신 프로토콜 조사 + Jabber 프로토콜 설명
	https://myeonguni.tistory.com/820
* WebSocket 프로토콜 vs HTTP 프로토콜
	https://sendbird.com/ko/developer/tutorials/websocket-vs-http-communication-protocols
* STOMP 프로토콜을 통한 채팅 기능 구현
	https://velog.io/@kimgunwooo/실시간-채팅-기능-개발-STOMP
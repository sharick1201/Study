## 채팅 기능 기본 요구사항
채팅 서비스는 기본적으로 아래 기능을 요구한다.

1. **메세지 발신**
	* 클라이언트(사용자)가 애플리케이션을 통해 메시지를 발신한다. 이 메시지는 서버로 전송된다.
	* 서버는 클라이언트에서 수신된 메세지를 받아서 처리한다.
		
2. **수신자(recipient) 결정**
	* 서버는 메시지의 수신자를 결정한다.
		* 여기에서 말하는 수신자(recipient)란?
			* 메세지를 받을 사용자 또는 그룹
			* 수신자는 메세지의 내용에 따라 다를 수 있다.
				* 즉, 특정 사용자 ID를 기반으로 수신자를 설정하거나, 채팅룸 ID를 기반으로 수신자를 설정할 수도 있다.
3. **메세지 전달**
	* 수신자가 온라인 상태인지 확인한다.
		* 여기에서 말하는 온라인 상태란? 수신자에 해당하는 클라이언트가 서버에 연결되어 있고, 메세지를 받을 준비가 되어있는 상태
	* 수신자의 접속 상태에 따라 다음 로직이 달라진다.
		* 수신자가 온라인 상태라면, 서버는 해당 클라이언트에게 메세지를 즉시 전달한다.
		* 수신자가 오프라인 상태라면, 서버는 해당 메세지를 보관한다.
			* 이때 메세지는 수신자가 다시 온라인 상태가 될 때까지 대기한다.
			* 수신자가 온라인 상태로 돌아오면, 서버는 보관된 메세지를 해당 사용자에게 전달한다.

예컨대 사용자A가 사용자 B에게 메세지를 보낸다고 하자.
그럼 서버는 메세지를 수신하고, 수신자가 사용자 B임을 확인한다.
다음으로 서버는 사용자 B가 온라인 상태인지 오프라인 상태인지 확인한다.
온라인 상태라면, 메세지를 즉시 전달한다. 오프라인 상태라면, 사용자 B가 온라인 상태가 될 때까지 기다린다.

<span style="background:rgba(240, 107, 5, 0.2)">→ 그럼 제때제때 안 보는 사람이 많으면 많을수록 기다리는 데에 자원이 소비되고, 기능 저하가 일어나는 건가? 서버는 어떤 식으로 '대기'하는가?</span>
* [[서버는 '어떻게' 메세지를 대기시키는가?]]

## 요구사항 충족을 위한 네트워크 통신 프로토콜 고려

상술한 채팅 기능 요구사항을 충족시키기 위하여, 채팅을 시작하고자 하는 클라이언트는 **네트워크 통신 프로토콜**을 사용하여 요청을 보낸다.

 이때, 어떤 통신 프로토콜을 사용할 것인가?

* HTTP + 롱 폴링
	* HTTP
		* 클라이언트가 연결을 만드는, 요청-응답 기반 단방향 프로토콜
			* 클라이언트가 요청을 보내야만 서버가 응답한다. 
			* 서버가 클라이언트에게 먼저 데이터를 전송할 수는 없다.
		* 메세지를 송신할 때는 송신자(sender)에 해당하는 클라이언트가 먼저 통신을 요청하기 때문에, 사용해볼 수는 있겠으나, 단방향 프로토콜이기 때문에 메세지를 수신받는 로직이 매우 복잡해진다.
			* 이를 해결하기 위해 폴링이나 롱 폴링 기술을 접목한다.
	* 폴링이란?
		* 클라이언트가 주기적으로 서버에게 새 메세지가 있는지 물어보는(요청하는) 기술
		* 주기적으로 요청을 보내는 것이기 때문에, 폴링을 자주 할수록 비용이 높아진다.
		* 그렇다고 요청 보내는 주기를 줄이면, 실시간성에 크게 위배된다.
		* 동기화할 필요가 없는 경우(채팅 메세지가 없을 때) 서버 자원이 불필요하게 낭비된다.
	* 롱 폴링이란?
		* 폴링의 단점을 개선하고자 나온 기법
		* 기존 폴링 방식 + 새 메세지가 있는지 물어볼 때(요청을 받았을 때),
			* 메세지가 있다면, 바로 해당 메세지를 응답으로 반환한다.
			* 메세지가 없다면, 응답을 보내지 않고 <u>대기</u>한다.
				* 대기하는 중 새 메세지가 온다면, 그 메세지를 바로 반환한다.
				* 대기는 타임아웃이 발생할 때까지 지속된다.
			* 이때, 클라이언트는 새 메세지가 반환되거나 타임아웃이 될 때까지 연결을 유지한다.
			* 그런데 서버 입장에선 클라이언트가 연결을 해제했는지 아닌지를 알 수가 없다.
		* 게다가 여전히 주기적으로 요청을 보내는 것이기 때문에, 비효율적이다.

* WebSocket
	* 클라이언트-서버 간의 양방향(Full-Duplex) 실시간 통신 기반 프로토콜
	* 서버가 클라이언트에게 비동기 메세지를 보낼 때 가장 널리 사용하는 기술
	* 단일 TCP 연결을 통해 초기 연결 설정 후, 양방향 통신 가능
		* 풀어 이야기하자면, 클라이언트가 연결을 요청할 때는 HTTP 연결로 수행하고, 성공하면 Web Socket 연결로 업그레이드된다.
	* 어떻게 양방향 통신이 가능하느냐? 지속적이 연결을 통해.
	* HTTP 프로토콜이 사용하는 기본 포트번호를 그대로 사용한다.

* Jabber
	* XMPP(Extensible Messageing and Presence Protocol) 기반의 오픈 프로토콜
		* XMPP: XML 기반의 클라이언트-서버 통신
	* Google Talk, Facebook Chat, Apple iMessage이 사용 중이다.
	* XML을 사용하여 실시간 메세지와 상태 정보를 교환한다.

* STOMP + 외부 브로커
	* 메세지 전송을 효율적으로 하기 위해 등장한 프로토콜
	* 텍스트, Pub/Sub 기반의 메세징 프로토콜
		* Pub/Sub(발행/구독) 패턴
			* 발행자와 구독자 사이에 메세지 브로커가 있다. 브로커는 메세지를 전달하고 관리하는 역할이다.
			1. 발행자가 메세지를 생성하고 특정 주제에 발행한다.
			2. 브로커가 발행된 메세지를 수신하고, 이를 해당 주제를 구독한 구독자에게 전달한다
			3. 구독자는 관심 있는 주제를 구독하고, 해당 주제에 발행된 메세지를 수신한다.
	* 클라이언트가 오프라인일 때 메세지를 저장할 수 있는 기능이 부족하기 때문에 메세지 손실의 위험이 있다.
	* 그래서 이 문제를 해결하기 위해 주로 외부 메시지 브로커(예: RabbitMQ, Kafka, Active MQ, Redis Pub/Sub)와 함께 사용된다.
		* 메세지 브로커란?
			* 데이터 교환을 위해 사용되는 중간 관리 소프트웨어
			* 발신자와 수신자 사이에서 데이터를 중개한다.
			* 메세지를 수집, 임시저장, 변환, 라우팅하는 역할
			* 이를 사용하면, 시스템 간 통신이 비동기적, 독립적, 안정적으로 이루어진다.

- WebRTC:
    - 중간 서버 없이 클라이언트 간 직접(P2P) 연결을 통해 데이터를 주고받는다.
        - P2P란?
            - 네트워크에서 중앙 서버 없이 여러 컴퓨터(또는 장치)들이 직접 데이터를 주고받는 방식
    - 음성, 영상, 텍스트 등의 다양한 데이터를 실시간으로 전송할 수 있다.
    - P2P 연결을 위한 시그널링 서버가 필요하다.
        - 시그널링 서버란?
            - P2P 연결을 설정하기 위한 초기 작업을 담당하는 중개 서버
            - 처음에 두 클라이언트들이 연결되기 위해서는 상대방의 정보(네트워크 정보, SDP, ICE Candidates 등)가 필요하다. 또한 연결 시작, 유지, 종료 관련한 세션이 관리되어야 한다. 이 역할을 해주는 게 시그널링 서버.
	            
- gRPC:
    - Google이 개발한 고성능 통신 프레임워크
    - 양방향 스트리밍이 가능하다.
        - 양방향 통신은 클라이언트와 서버가 동시에 데이터를 주고받을 수 있는 모든 형태의 통신을 의미하고, 양방향 스트리밍은 양방향 통신 중에서도 데이터를 지속적으로, 작은 단위로 주고받는 특정 형식이다.
    - 마이크로서비스 간의 통신에 적합하다.
    - HTTP/2를 기반으로 하며, 데이터를 바이너리 형식(Protobuf)으로 전송해 속도가 빠르다.
    - 비디오 스트리밍, 대규모 분산 시스템 내 실시간 데이터 처리에 주로 사용된다.

#### 통신 프로토콜 비교
##### 특징 비교
| **항목**       | **HTTP + 롱 폴링**               | **WebSocket**              | **Jabber (XMPP)**         | **STOMP**                            | WebRTC          | gRPC                |
| ------------ | ----------------------------- | -------------------------- | ------------------------- | ------------------------------------ | --------------- | ------------------- |
| **통신 모델**    | 요청-응답 기반 (클라이언트가 요청하면 서버가 응답) | 양방향 통신 (Full-Duplex)       | XML 기반의 클라이언트-서버 통신       | Pub/Sub 기반 메시징                       | P2P 통신          | 양방향 스트리밍            |
| **연결 유지**    | 요청마다 새로운 연결 생성                | 단일 지속 연결                   | 지속적인 연결 유지                | WebSocket 또는 TCP를 통해 연결 유지           | P2P 연결          | HTTP/2 기반 지속 연결     |
| **실시간성**     | 제한적 실시간 (응답 지연 가능성 있음)        | 실시간 메세징 가능                 | 실시간 메시징 가능                | 실시간 메시징 가                            | 실시간 P2P 가능      | 실시간 스트리밍 가능         |
| **프로토콜 기반**  | HTTP                          | WebSocket (RFC 6455)       | XMPP (IETF 표준)            | WebSocket, TCP                       | STUN/TURN 필요    | HTTP/2              |
| **데이터 구조**   | 단순 텍스트 또는 JSON                | 바이너리 및 텍스트 모두 지원           | XML 형식                    | 텍스트 기반의 프레임 구조                       | 멀티미디어 데이터 지원    | 바이너리 데이터 (Protobuf) |
| **확장성**      | 낮음 (서버 자원 소모 큼)               | 높음 (단일 연결로 효율적 자원 활용)      | 높은 확장성 (네임스페이스를 통한 확장 가능) | 외부 메시지 브로커(RabbitMQ, Kafka 등)와 연동 가능 | NAT 환경에서 제약 있음  | 높은 확장성              |
| **사용 사례**    | 비실시간 애플리케이션, 간단한 데이터 전송       | 채팅, 게임, 주식 거래 등 실시간 애플리케이션 | 채팅, 협업 도구                 | 채팅, 알림 서비스, 대규모 메시징 시스템              | 화상회의, 음성/영상 채팅  | 마이크로서비스 통신          |
| **보안**       | HTTPS를 통한 암호화                 | TLS 지원                     | TLS 및 SASL 인증 지원          | WebSocket 보안(TLS), 브로커 인증            | SRTP(보안 RTP) 지원 | TLS                 |
| **복잡성**      | 구현이 간단하지만 비효율적                | 구현이 상대적으로 복잡하지만 효율적        | 중간 정도의 복잡도                | 매우 간단하나WebSocket 위에서 동작하며 추가적인 설정 필요 | 시그널링/TURN 서버 필요 | 복잡한 구현              |
| **브라우저 호환성** | 모든 브라우저에서 지원                  | 최신 브라우저에서 지원               | 브라우저 비의존적                 | WebSocket을 지원하는 환경에서 사용 가능           |                 |                     |

##### 장단점 비교
우리가 구현하고자 하는 서비스의 요구사항, 관련사항과 관련 없는 특징은 취소줄로 표시하였다.

* HTTP + 롱 폴링
	* 장점
		* 구현이 간단하다.
		* 기존 HTTP 기반 기술과 호환성이 좋다.
	* 단점
		* 주기적으로 요청을 보내는 것이기 때문에, 자원 낭비가 심하다. 서버 리소스를 많이 차지한다.
		* 완전한 실시간성을 보장하지 못한다.
		* 대기 중에, 서버 입장에선 클라이언트가 연결을 해제했는지 아닌지를 알 수가 없다.
		* 라운드 로빈 알고리즘을 사용하는 경우 메세지를 보내는 클라이언트와 수신받는 클라이언트가 같은 채팅 서버에 접속하지 않을 수도 있다.
			* HTTP 서버들은 보통 무상태 서버이니, 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용한다면... 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴딩 연결을 가지고 있지 않은 서버일 수 있는 것

* WebSocket
	* 장점
		* 실시간 데이터 전송이 가능하므로 지연 시간이 최소화된다. 실시간 데이터 전송이 가능하므로 사용자 접속 상태, 사용자 입력 상태 정보도 가져올 수 있다.
		* 서버에서 클라이언트로 데이터를 줄 수 있어서 효율적이다.
		* HTTP 프로토콜이 사용하는 기본 포트번호를 그대로 사용하기 때문에, 방화벽이 있는 환경에서도 일반적으로 잘 동작한다.
	* 단점
		* HTTP에 비해, 구현이 비교적 복잡하다.
		* 채팅방마다 세션을 관리해야 해서 번거롭다.
		* 웹소켓 연결은 항시 유지되어야 하기 때문에, 연결 유지 비용이 높아 연결 관리를 효율적으로 해야 한다.
			
* Jabber
	* 장점
		* 사용자 접속 상태, 사용자 입력 상태 정보를 가져올 수 있다.
		* 강력한 보안(TLS/SASL)을 제공한다.
		* XML 네임스페스를 사용하면 Jabber 프로토콜을 커스텀할 수 있다.
		* 서버를 오픈하지 않고 프로토콜만 활용하여 사용할 수 있다.
		* ~~Jabber를 사용하는 서버들간의 통신이 가능하게 지원하기 때문에, 다른 도메인을 사용하는 사용자들과 대화를 가능하게 해준다.~~
			* ~~단, Jabber를 사용하는 Server가 공개되어야지만 가능~~
			* ~~ex) iMessage 사용자와 Facebook Chat 사용자 간 대화 가능~~
	* 단점
		* XML 기반이라 데이터 크기가 커질 수 있고, 대규모 트래픽 처리 시 성능 저하가 일어난다.
		
* STOMP + 외부 브로커
	* 장점
		* 구현이 간단하다.
		* 다양한 언어와 플랫폼에서 지원된다.
		* 메세지 브로커와 쉽게 통합 가능하다.
		* Spring Security를 이용하여 채팅 엔드포인트의 권한을 제어할 수 있다.
		    - ex) JWT 확인을 통해 원하는 사용자만 채팅에 입장하도록 만들 수 있다.
		- EventListner를 통해 방 입장, 퇴장 시에 원하는 메시지를 추가할 수 있다.
		- 비동기적 통신으로, 발행자가 구독자의 상태를 알 필요가 없기 때문에 성능 향상 및 응답성을 개선한다.
	- 단점
		- 외부 브로커도 관리해야 한다.
		- 외부 브로커의 인프라 비용이 추가된다.
		- 외부 브로커로 인하여 네트워크 지연이 발생할 수도 있다.

* WebRTC
	* 장점
		* 클라이언트 간 직접 연결을 통해 서버 부하를 줄이고 지연 시간을 최소화할 수 있다.
		* 음성, 영상, 텍스트 등 다양한 데이터 유형을 실시간으로 전송할 수 있어 화상회의나 음성 채팅에 적합하다.
		* 대부분의 최신 브라우저에서 기본적으로 지원되어 플러그인 없이 동작한다.
	* 단점
		* P2P의 연결 설정을 위해 WebSocket이나 다른 프로토콜을 사용하는 시그널링 서버가 필요하다
		* NAT(Network Address Translation) 환경에서는 STUN/TURN 서버를 추가로 설정해야 해서 너무너무 복잡해진다.
		* 음성/영상 통신에 최적화되어 있어서, 단순 텍스트 기반 채팅에 사용하기에는 구현 시간이 아깝다.
	
* gRPC
	* 장점
		* 고성능 데이터를 압축하여 빠르고 효율적으로 전송할 수 있다.
		* 양방향 스트리밍을 지원하여 실시간 통신에 적합하다.
		* 다양한 언어를 지원한다.
	* 단점
		* RESTful API보다 구현이 복잡하다.
		* 단순한 채팅 애플리케이션에 적용하기에는 필요 이상으로 복잡하다. 

## 결정된 통신 프로토콜: WebSocket 알아보기

#### WebSocket 통신 과정

[![What are WebSockets and Why are they Used?](https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd58bb11f-3727-4ed2-bcbd-dbffe55069c7_1076x1086.png)

1. HTTP 오프닝 핸드쉐이크
	* 클라이언트가 서버에 연결 요청을 보낸다.
	* 요청 헤더:
		* HTTP 프로토콜을 사용한 `GET` 요청
			* HTTP 버전 1.1 이상을 요구
		* Upgrade: 프로토콜 전환을 요구하는 헤더
			* Upgrade 값이 없거나, websocket이 아니면 cross-protocol attack이라고 간주하여 웹소켓 접속을 중단시킨다.
		* Connection: 현재 전송이 완료된 후 접속 유지 여부를 알리는 헤더
			* 웹소켓 요청 시에는 반드시 Upgrade 값을 가짐
			* Connection 값이 없거나, Upgrade가 아니면 웹소켓 접속을 중단시킨다.
		* Sec-WebSocket-Key: 유효한 요청 검증을 위한 키 값
		* Sec-WebSocket-Version: 클라이언트가 사용하고자 하는 웹소켓 프로토콜 버전
	* 응답 헤더:


* 요청 헤더 예시:
```
GET /chat HTTP/1.1
Host: duckmelang.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```
* 응답 헤더 예시:
* 












----


참고자료:
* 채팅 서비스 설계 시 고려점
	통신 아키텍쳐 측면: https://guti-coding.tistory.com/182
	서버 아키텍쳐 측면: https://guti-coding.tistory.com/190?category=1266186
	
* 채팅 시스템 설계 (『가상 면접 사례로 배우는 대규모 시스템 설계 기초』 기반 포스팅)
	https://azderica.github.io/til/docs/dev/system-design-interview/ch12/
	https://velog.io/@gidskql6671/채팅-시스템-설계
	https://jaeseo0519.tistory.com/410 (책 기반 + 자세한 추가 정보도 많음!)
	
* 카카오엔터의 채팅 플랫폼 구현기
	https://kakaoentertainment-tech.tistory.com/109



* 채팅 통신 프로토콜 조사 + Jabber 프로토콜 설명
	https://myeonguni.tistory.com/820
* WebSocket 프로토콜 vs HTTP 프로토콜
	https://sendbird.com/ko/developer/tutorials/websocket-vs-http-communication-protocols
* STOMP 프로토콜을 통한 채팅 기능 구현
	https://velog.io/@kimgunwooo/실시간-채팅-기능-개발-STOMP
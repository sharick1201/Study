
메시지를 대기시키는 과정은 일반적으로 **비동기적 처리**와 **저장소 활용**을 기반으로 이루어진다.

이를 단계별로 설명하면...
#### 1. **메시지의 영구 저장**
- 수신자가 오프라인 상태일 경우, 서버는 메시지를 메모리(RAM)가 아닌 영구 저장소(예: 데이터베이스, 메시지 큐, 파일 시스템)에 저장한다.
- 데이터베이스는 일반적으로 NoSQL DB(예: MongoDB, Cassandra)가 선호된다. 이는 구조화되지 않은 데이터를 빠르게 저장하고 검색할 수 있기 때문이다.
- 이렇게 하면 RAM과 같은 휘발성 자원을 사용하지 않고도 메시지를 안전하게 대기시킬 수 있다.

##### 2. **비동기 처리**
- 서버는 오프라인 사용자에 대한 메시지를 실시간으로 '계속' 확인하지 않습니다. 대신, **비동기 이벤트 기반 처리**를 사용한다.
  - 예: 사용자가 다시 온라인 상태가 되면, 서버는 해당 이벤트를 감지하고 저장된 메시지를 검색해 전달한다.
  - 이를 위해 **이벤트 기반 아키텍처**(예: WebSocket 연결 상태 변화 감지, 푸시 알림 이벤트 등)가 활용된다.

##### 3. **메시지 큐 활용**
- 일부 시스템에서는 메시지 큐(예: RabbitMQ, Kafka)를 사용하여 메시지를 대기시킨다.
  - 메시지가 큐에 들어가면, 수신자가 온라인 상태로 돌아올 때까지 큐에 보관된다.
  - 이 방식은 데이터베이스를 사용하는 것보다 더 가볍고 빠른 처리가 가능하다.

### 자원 소비 문제와 해결 방법

#### 자원 소비 문제: 많은 사용자가 오프라인일 경우
- 오프라인 사용자가 많아질수록 대기 중인 메시지가 증가한다.
- 이는 데이터베이스의 읽기/쓰기 부하를 증가시키거나 큐의 크기를 크게 차지할 수 있다.

### 해결 방법
1. **효율적인 데이터베이스 설계**
   - 메시지는 일반적으로 "읽히면 삭제"되는 특성이 있으므로, TTL(Time-To-Live)을 설정하거나 만료된 데이터를 주기적으로 삭제하는 전략을 사용한다.
   - 예를 들어, Redis 같은 인메모리 데이터베이스를 사용하면 TTL을 통해 일정 시간이 지나면 자동으로 데이터를 삭제할 수 있다.

2. **배치 처리**
   - 오프라인 사용자에게 쌓인 메시지는 하나씩 처리하지 않고 배치(batch)로 묶어 한 번에 전송한다. 이렇게 하면 네트워크 및 서버 부하를 줄일 수 있다.

3. **분산 시스템 활용**
   - 대규모 사용자 기반에서는 단일 서버가 아닌 분산 시스템을 활용하여 부하를 분산시킨다.
   - 예: 메시지를 여러 노드에 분산 저장하고, 특정 노드가 담당하는 사용자에게만 메시지를 전달하도록 설계.

4. **메시지 크기 제한**
   - 각 메시지의 크기를 제한하거나 압축하여 저장 공간과 네트워크 대역폭을 절약한다.

### '대기' 중 자원 소비를 최소화하는 방식

서버가 "대기"하는 것은 단순히 연결을 유지하는 것이 아니라 다음과 같은 방식으로 효율적으로 관리된다.

1. **WebSocket 연결 관리**
   - 온라인 상태의 사용자에게 실시간으로 메시지를 전달하기 위해 WebSocket 연결을 유지한다.
   - WebSocket은 HTTP보다 훨씬 적은 리소스를 소비하며, 연결이 끊어질 경우 즉시 감지할 수 있다.

2. **오프라인 상태 관리**
   - 오프라인 사용자는 WebSocket 연결이 없으므로 별도의 자원을 소비하지 않는다.
   - 대신, 서버는 해당 사용자를 위한 대기 중인 메시지만 저장소에 보관한다.

3. **알림 시스템 통합**
   - 푸시 알림(Firebase Cloud Messaging 등)을 통해 오프라인 사용자에게 새로운 메시지가 도착했음을 알린다.
   - 이때 푸시 알림은 클라이언트가 다시 서버와 연결하도록 유도하는 역할만 하며, 실제 메시지는 클라이언트가 온라인 상태로 돌아온 후 전송된다.





정리하자면, 서버는 오프라인 사용자에게 "대기" 중인 메시지를 효율적으로 관리하기 위해 다음과 같은 전략을 사용한다:

- 영구 저장소(DB 또는 큐)에 비동기로 저장
- 이벤트 기반 아키텍처로 실시간 확인 대신 이벤트 발생 시 처리
- 분산 시스템 및 배치 처리를 통해 부하 분산

이를 통해 "대기" 자체가 서버 자원을 과도하게 소모하지 않도록 설계된다. 



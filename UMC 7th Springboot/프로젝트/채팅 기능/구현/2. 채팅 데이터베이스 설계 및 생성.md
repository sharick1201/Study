## 데이터베이스 설계

![[Pasted image 20250204164043.png]]
- Message 테이블은 MongoDB
- ChatRoom 테이블은 MySQL


- 추가 고려사항에 대한 attribute는 기능 구현 완성 후 추가한다.
    - MongoDB는 attribute 수정에 유연하다.
    
- 1:1 채팅의 경우 별도의 채팅방 테이블을 만들 필요는 없다.
    
    - 만들게 될 경우 RDB(MySQL)에 저장
    - 추후 필요하게 되면 설정하면 될듯
     ⇒ 우리가 구현하고자 하는 서비스의 채팅방이 당근처럼 게시물 기반이어서 채팅방 엔티티가 따로 필요하다!



## 세팅

### 로컬에 데이터베이스 생성하기

[[Docker에 MongoDB 설치하고 데이터베이스 생성하기]]

### 프로젝트에 의존성 추가 & yml에 연결 설정 추가

build.gradle의 dependencies에 MongoDB의 의존성을 추가한다.

```java
	implementation "org.springframework.boot:spring-boot-starter-data-mongodb"
```

application-local.yml, application-prod.yml 에 로컬 MongoDB 관련 설정을 추가한다.

```yaml
 spring:
	 data:
    mongodb:
      uri: mongodb://localhost:27017/duckmelang
```

설정을 완료하고 gradle을 다시 bulid한 후, Application을 실행시켰을 때, 아래와 같은 로그가 찍힌다면 성공적으로 연결된 것이다.

```
2025-02-04T16:22:42.149+09:00  INFO 50014 --- [           main] org.mongodb.driver.client                : MongoClient with metadata {"driver": {"name": "mongo-java-driver|sync|spring-boot", "version": "5.0.1"}, "os": {"type": "Darwin", "name": "Mac OS X", "architecture": "aarch64", "version": "15.2"}, "platform": "Java/Homebrew/17.0.13+0"} created with settings MongoClientSettings{readPreference=primary, writeConcern=WriteConcern{w=null, wTimeout=null ms, journal=null}, retryWrites=true, retryReads=true, readConcern=ReadConcern{level=null}, credential=null, transportSettings=null, commandListeners=[], codecRegistry=ProvidersCodecRegistry{codecProviders=[ValueCodecProvider{}, BsonValueCodecProvider{}, DBRefCodecProvider{}, DBObjectCodecProvider{}, DocumentCodecProvider{}, CollectionCodecProvider{}, IterableCodecProvider{}, MapCodecProvider{}, GeoJsonCodecProvider{}, GridFSFileCodecProvider{}, Jsr310CodecProvider{}, JsonObjectCodecProvider{}, BsonCodecProvider{}, EnumCodecProvider{}, com.mongodb.client.model.mql.ExpressionCodecProvider@6ce940d, com.mongodb.Jep395RecordCodecProvider@34da2b4a, com.mongodb.KotlinCodecProvider@6c439a57]}, loggerSettings=LoggerSettings{maxDocumentLength=1000}, clusterSettings={hosts=[localhost:27017], srvServiceName=mongodb, mode=SINGLE, requiredClusterType=UNKNOWN, requiredReplicaSetName='null', serverSelector='null', clusterListeners='[]', serverSelectionTimeout='30000 ms', localThreshold='15 ms'}, socketSettings=SocketSettings{connectTimeoutMS=10000, readTimeoutMS=0, receiveBufferSize=0, proxySettings=ProxySettings{host=null, port=null, username=null, password=null}}, heartbeatSocketSettings=SocketSettings{connectTimeoutMS=10000, readTimeoutMS=10000, receiveBufferSize=0, proxySettings=ProxySettings{host=null, port=null, username=null, password=null}}, connectionPoolSettings=ConnectionPoolSettings{maxSize=100, minSize=0, maxWaitTimeMS=120000, maxConnectionLifeTimeMS=0, maxConnectionIdleTimeMS=0, maintenanceInitialDelayMS=0, maintenanceFrequencyMS=60000, connectionPoolListeners=[], maxConnecting=2}, serverSettings=ServerSettings{heartbeatFrequencyMS=10000, minHeartbeatFrequencyMS=500, serverListeners='[]', serverMonitorListeners='[]'}, sslSettings=SslSettings{enabled=false, invalidHostNameAllowed=false, context=null}, applicationName='null', compressorList=[], uuidRepresentation=JAVA_LEGACY, serverApi=null, autoEncryptionSettings=null, dnsClient=null, inetAddressResolver=null, contextProvider=null}
2025-02-04T16:22:42.155+09:00  INFO 50014 --- [localhost:27017] org.mongodb.driver.cluster               : Monitor thread successfully connected to server with description ServerDescription{address=localhost:27017, type=STANDALONE, state=CONNECTED, ok=true, minWireVersion=0, maxWireVersion=25, maxDocumentSize=16777216, logicalSessionTimeoutMinutes=30, roundTripTimeNanos=8925667}
```

- 로그 설명
    - MongoClient 생성: MongoCilent는 애플리케이션이 MongoDB 데이터베이스와 통신하기 위해 사용하는 클라이언트 객체이다.
    - MongoDB 서버 연결 성공: 직전에 생성된 MongoClient가 `localhost:27017`에 실행 중인 MongoDB 서버에 성공적으로 연결되었음을 알려준다.



## 엔티티 생성

### 채팅 메세지 엔티티(MongoDB)

JPA의 `@Entity` 대신 Spring Data MongoDB의 `@Document`를 사용하여 컬렉션 타입으로 지정한다.

```java
@Document(collection = "message")  // collection = "실제 mongoDB 내 컬렉션 이름")
@Getter
@Builder
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
public class Message {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long senderId;   // 메세지를 보낸 사람
    
    private Long receiverId;   // 메세지를 받은 사람
    
    private Long chatRoomId;   // 대화가 이루어지고 있는 채팅방 ID

    private String content;   // 메세지 내용
    
    @CreatedDate
    private LocalDateTime createdAt;
    
}
```

### 채팅방 엔티티(MySQL)

```java
@Entity
@Getter
@Builder
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
public class ChatRoom {

		@Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long postId;   // 게시글 id (작성자 쪽 id 조회 가능)
    
    private Long otherMemberId;   // 게시글을 보는 쪽 회원
    
    private boolean hasMatched;   // 매칭 성사 여부

    private boolean hasSenderReviewDone;    // 작성자 리뷰 완료 여부
    
    private boolean hasReceiverReviewDone; // 보는쪽 리뷰 완료 여부
    
}
```




#### 참고자료

- 키-값 저장소 설계 [https://azderica.github.io/til/docs/dev/system-design-interview/ch6](https://azderica.github.io/til/docs/dev/system-design-interview/ch6)
    
- WebSocket으로 채팅 구현하기(+MongoDB 사용하기) :이건 Node.js로 구현 [https://princesskiji.tistory.com/155](https://princesskiji.tistory.com/155)
    
- MongoDB, Springboot로 채팅 구현 [https://khdscor.tistory.com/115](https://khdscor.tistory.com/115)
    
- [https://velog.io/@gds0813/spring-boot로-11채팅-구현하기웹소켓-3](https://velog.io/@gds0813/spring-boot%EB%A1%9C-11%EC%B1%84%ED%8C%85-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0%EC%9B%B9%EC%86%8C%EC%BC%93-3)
    
- [https://jaeseo0519.tistory.com/410#4. 데이터 모델-1](https://jaeseo0519.tistory.com/410#4.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EB%AA%A8%EB%8D%B8-1)
    
- [https://c3epmos.tistory.com/85](https://c3epmos.tistory.com/85)
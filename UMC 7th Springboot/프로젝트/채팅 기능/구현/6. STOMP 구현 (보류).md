
기본적인 채팅 기능을 완료하였으니, 메세지 프로토콜의 표준화를 위해 STOMP를 추가하여 사용하기로 했다.

## STOMP를 현재 프로젝트에 추가하는 이유

[[STOMP]]

1. 메세지 구조의 표준화
    
    1. STOMP를 통해, 기존 WebSocket에서는 정의내리지 못했던 메세지 구조를 정의내릴 수 있다.
    2. 따라서 메세지 교환을 일관성 있게 관리할 수 있다. (그래서 알아보기 쉽다)
2. 추후 시스템 확장에도 유리하다.
    
    1. 1:N 채팅으로 확장하기 쉽다
3. 보안을 강화시킬 수 있다.
    
    1. 메세지 헤더로 인증 정보를 전달할 수 있다.
4. 고급 기능 구현이 용이하다.
    
    1. 메시지 헤더를 활용한 메타데이터 전송, 에러 핸들링, 재연결 로직 등을 쉽게 구현할 수 있다.

## STOMP 구현

### 어떤 메세지 브로커를 사용할 것인가?

- 인메모리 메세지 브로커(Simple Message Broker)
    
    - 스프링에서 제공하는 Simple Message Broker를 사용하면 간단하게 구현이 가능하다.
    - 다만 스프링부트 서버 내부 메모리에서 동작하기 때문에, 아래 문제가 발생한다.
        - 서버 다운, 재시작 시 메세지 브로커에 있는 데이터 유실 가능성
        - 다중 서버 사용 시 서버 간 채팅방 공유 불가능
- Redis Pub/Sub
    
    - Message Broker가 여러 서버에서 접근할 수 있도록 한다.
    - 직접적으로 STOMP 프로토콜을 지원하지는 않는다. 다만 Redis의 Pub/Sub 기능을 통해 메세지 브로커로 사용할 수 있다.
    - STOMP 프로토콜을 지원하는 메시지 브로커(RabbitMQ) 도입 시, 더 고도화된 기능(메시지 전달 보장, SSL 지원)을 사용할 수 있지만, 현재 Redis 데이터베이스를 사용하고 있기도 하고, 채팅 정보 세션에 적합한 key-value 데이터베이스이며, 빠르고 쉽게 구현할 수 있어 Redis를 채택하였다.
    - 근데 Redis Pub/Sub는 데이터 유실 위험이 있다…?
        - 메세지 전송 후 전송 성공 여부와 상관 없이 바로 메세지를 삭제하기 때문.

⇒ 지금 시점에 STOMP를 구현하는 게 맞을까?

- 현재 1:N 채팅과 다중 서버를 사용할 예정이 아닌데 메세지 구조 표준화만을 위해서 할 필요가 있을까? 다른 기능을 완성시키고 시간이 남으면 하는 게 맞지 않을까?

<aside> 📌 지우님과 논의: 서비스 요구사항에 비해 오버엔지니어링인듯 하여 일단 타 서비스 구현 후 여유가 되면 추가로 구현하는 것으로 보류

</aside>






## 참고자료

[https://velog.io/@leeseunghee00/Spring-채팅-구현-STOMP-Redis-PubSub](https://velog.io/@leeseunghee00/Spring-%EC%B1%84%ED%8C%85-%EA%B5%AC%ED%98%84-STOMP-Redis-PubSub)

[https://tioon.tistory.com/194](https://tioon.tistory.com/194)

[https://modutaxi-tech.tistory.com/6](https://modutaxi-tech.tistory.com/6)
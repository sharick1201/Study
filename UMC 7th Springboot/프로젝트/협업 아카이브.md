* 협업 규칙 설정
	* 브랜치 전략
	* 코드 컨벤션
	* PR 규칙
	* 패키지 전략
	Git 공부... 더 이상 미룰 수 없다


2024-01-09
* 팀원 분이 생성하고 초대해주신 Git Organization에서 백엔드 repository를 내 로컬로 clone해왔다.

2024-01-11
* API 명세서 작성
* 이슈 생성
* 브랜치 생성
	* 나는 entity 작성 반을 맡아 feature/#2 브랜치를 파서 작성 중에 있다. 이때 commit의 주기를 어떻게 하는 게 좋을까?
		* commit은 최대한 잘게 쪼개어 최대한 자주 올리는 게 좋다고들 한다.
			* https://velog.io/@awfjol2008/Git-커밋-단위-및-주기에-관한-고민
		* 유의미한 커밋을 만들어 내는 것은 좋지만, 그것보다 내가 작업한 결과물을 동료들에게 빠르게 공유하는 것이 훨씬 중요하다고 한다. (이유: 충돌 최소화)
			* https://bbbicb.tistory.com/70
	* feature/#2 entity 작성
		* @Id는 자동으로 유일성을 보장해준다. 따라서 @Column(unique = true) 작성할 필요 없음
		* member
			* gender 타입에 대한 고민...
			* 신원이 중요하니 birth는 notNull
			* 소개글 타입: varchar로 제안. text 타입은 저장 공간이 다르다보니 느릴 수 있음. 소개글이 500자를 넘길 것 같지는 않다. -> 이렇게 수정하는 걸로 픽스!
			* member_profile_image 매핑
				* orphanRemoval = true 옵션
					* 부모 엔티티에서 자식 엔티티가 제거되었을 때 해당 자식 엔티티를 데이터베이스에서 자동으로 삭제하도록 설정하는 기능
					* `profileImages` 리스트에서 특정 프로필 이미지를 제거하면, 그 프로필 이미지가 데이터베이스에서도 삭제되는 로직
		* member_profile_image
			* memberImage는 notNull
			* 회원 프로필 이미지를 단 하나만 조회할 수 있다면, 예전 프로필 사진은 아예 볼 수 없는 건지?
			* 프로필 이미지를 설정하지 않는다면, 기본 프로필 이미지가 설정된다. 그렇다면 1to1이 되어야 하는 게 맞는 듯
		* imageURL 속성의 varchar 길이를 통일해야 할 거 같다. eventCategory에는 1024로, profileImage에는 225로 되어 있음.
		* Auth_provider
			* PK로 있는 provider id 이거 뭐지
			* provider 속성 enum으로 하는 게 맞나?
		* 양방향 편의 메서드
			* 어디에 작성해야 하는가?
				* https://studyandwrite.tistory.com/535
			* 기존 관계 제거 로직이 필요한 이유
				1. 데이터 무결성 유지:두 엔티티 간의 관계가 변경될 때, 이전 관계를 제거하지 않으면 데이터베이스에 불필요한 연결이 남게 된다. 예를 들어, `Bookmark`가 새로운 `Post`에 연결되면, 이전 `Post`에 대한 연결을 제거해야 한다.
				2. 양방향 관계 일관성: 양방향 관계에서 한쪽만 업데이트하면 일관성이 깨질 수 있다. 예를 들어, `Bookmark`가 새로운 `Post`에 연결되었을 때, 이전 `Post`의 `bookmarkList`에는 여전히 해당 `Bookmark`가 남아 있게 된다. 이를 방지하기 위해 기존 관계를 제거하는 로직이 필요하다.
				3. 메모리 누수 방지: 불필요한 객체 참조가 남아 있으면, 가비지 컬렉터가 해당 객체를 수거하지 못해 메모리 누수가 발생할 수 있다. 기존 관계를 제거함으로써 이러한 문제를 예방할 수 있다.
			* 내일 일어나면 manyToOne에 널러블 설정 확인!
	* 커밋 메세지 수정
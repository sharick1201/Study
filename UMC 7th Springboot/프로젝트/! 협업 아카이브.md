* 협업 규칙 설정
	* 브랜치 전략
	* 코드 컨벤션
	* PR 규칙
	* 패키지 전략
	Git 공부... 더 이상 미룰 수 없다


<span style="background:#fff88f">2024-01-09</span>
* 팀원 분이 생성하고 초대해주신 Git Organization에서 백엔드 repository를 내 로컬로 clone해왔다.

<span style="background:#fff88f">2024-01-11</span>
* API 명세서 작성
* 이슈 생성
* 브랜치 생성
	* 나는 entity 작성 반을 맡아 feature/#2 브랜치를 파서 작성 중에 있다. 이때 commit의 주기를 어떻게 하는 게 좋을까?
		* commit은 최대한 잘게 쪼개어 최대한 자주 올리는 게 좋다고들 한다.
			* https://velog.io/@awfjol2008/Git-커밋-단위-및-주기에-관한-고민
		* 유의미한 커밋을 만들어 내는 것은 좋지만, 그것보다 내가 작업한 결과물을 동료들에게 빠르게 공유하는 것이 훨씬 중요하다고 한다. (이유: 충돌 최소화)
			* https://bbbicb.tistory.com/70
	* feature/#2 entity 작성
		* @Id는 자동으로 유일성을 보장해준다. 따라서 @Column(unique = true) 작성할 필요 없음
		* member
			* gender 타입에 대한 고민...
			* 신원이 중요하니 birth는 notNull
			* ~~소개글 타입: varchar로 제안. text 타입은 저장 공간이 다르다보니 느릴 수 있음. 소개글이 500자를 넘길 것 같지는 않다. ->~~ 이렇게 수정하는 걸로 픽스!
			* member_profile_image 매핑
				* orphanRemoval = true 옵션
					* 부모 엔티티에서 자식 엔티티가 제거되었을 때 해당 자식 엔티티를 데이터베이스에서 자동으로 삭제하도록 설정하는 기능
					* `profileImages` 리스트에서 특정 프로필 이미지를 제거하면, 그 프로필 이미지가 데이터베이스에서도 삭제되는 로직
		* member_profile_image
			* memberImage는 notNull
			* ~~회원 프로필 이미지를 단 하나만 조회할 수 있다면, 예전 프로필 사진은 아예 볼 수 없는 건지?~~
			* ~~프로필 이미지를 설정하지 않는다면, 기본 프로필 이미지가 설정된다. 그렇다면 1to1이 되어야 하는 게 맞는 듯~~
			* 회원 프로필 여러 개 볼 수 있는 것으로 PM과 카톡 협의.
		* ~~imageURL 속성의 varchar 길이를 통일해야 할 거 같다. eventCategory에는 1024로, profileImage에는 225로 되어 있음. ->~~ 1024로 통일하기로 서우님과 0112 카톡 협의.
		* Auth_provider
			* provider 속성 enum으로 하는 게 맞나?
		* MateRelationship
			* application_id 요거는 1대1 관계?
			* firstMember, secondMember 중복 방지 로직 고민
		* 양방향 편의 메서드
			* 어디에 작성해야 하는가?
				* https://studyandwrite.tistory.com/535
			* 기존 관계 제거 로직이 필요한 이유
				1. 데이터 무결성 유지:두 엔티티 간의 관계가 변경될 때, 이전 관계를 제거하지 않으면 데이터베이스에 불필요한 연결이 남게 된다. 예를 들어, `Bookmark`가 새로운 `Post`에 연결되면, 이전 `Post`에 대한 연결을 제거해야 한다.
				2. 양방향 관계 일관성: 양방향 관계에서 한쪽만 업데이트하면 일관성이 깨질 수 있다. 예를 들어, `Bookmark`가 새로운 `Post`에 연결되었을 때, 이전 `Post`의 `bookmarkList`에는 여전히 해당 `Bookmark`가 남아 있게 된다. 이를 방지하기 위해 기존 관계를 제거하는 로직이 필요하다.
				3. 메모리 누수 방지: 불필요한 객체 참조가 남아 있으면, 가비지 컬렉터가 해당 객체를 수거하지 못해 메모리 누수가 발생할 수 있다. 기존 관계를 제거함으로써 이러한 문제를 예방할 수 있다.
			* 내일 일어나면 manyToOne에 널러블 설정 확인!
	* 커밋 메세지 수정
		* https://shape-coding.tistory.com/entry/Git-Git-커밋-메시지-수정하는-방법-Change-Commit-Message

<span style="background:#fff88f">2024-01-12</span>
* git push
	* Feature/#2 완성! (연관관계 편의 메서드 제외 상태)
	* 현재 브랜치 확인
	* 원격 저장소 연결 확인
	* 로컬 브랜치를 원격 저장소에 푸시 `git push -u origin feature/#2`
		*  `-u` 옵션은 `feature/#2` 브랜치를 원격 저장소의 `feature/#2` 브랜치와 연결(tracking)한다. 이후에는 `git push`만 입력해도 푸시할 수 있다.
	* 푸시 성공 메세지 확인 `branch 'feature/#2' set up to track 'origin/feature/#2'.`
* 이미지 속성들 varchar(1024)로 통일하기로 결정. 
* 서우님과 함께 TDD를 해보려고 하는데, Entity에서부터 시작하는지? 알아보기
	* https://velog.io/@nimoh/Spring-TDDTest-Driven-Development-시도해보기
	* https://ryuks.tistory.com/9
	* https://www.inflearn.com/community/questions/1412330/tdd-를-적용하면-구현하려는-기능에-필요한-객체들을-설계하고-들어가야-하는건가요?srsltid=AfmBOoouxVqaUjlDrR4tX7CChLBIsUL1tK5SZne4gp6ZfHQBpKbXkmv6
	* input과 output이 있는 repository부터 시작하는 게 일반적인듯.
	* 본격적으로 좀 해보려면 공부가 필요해보인다.
	
* 이제 서우님과 함께 반반씩 적은 entity를 통합하여 테스트해보려고 한다. 이 경우 브랜치를 어떤 식으로 해나가는게 좋을지?
	* 새로운 Feature 브랜치를 파고, 여기다가 기존 두 브랜치를 merge하는 편이 develop 브랜치의 안정성을 유지시킬 수 있으니 해당 방식으로 진행한다.
		* 새로운 통합 브랜치 생성
			develop 브랜치로 이동
			$ git checkout develop
			통합용 브랜치 생성
			$ git checkout -b feature/#8

		* 각 feature 브랜치를 통합 브랜치에 병합
			feature/#1 병합
			$ git merge --no-ff feature/#1
			feature/#2 병합
			$ git merge --no-ff feature/#2
			* merge: feature/#1 - not something we can merge라고 뜨길래 뭐지,,, 했는데 내가 그냥 feature/#1을 로컬에 체크아웃하지 않은 것이었다...!

		* 커밋 메세지 작성
			* vim이 열리면, 키보드에서 i를 눌러 insert mode로 전환한 후 작성한다.
			* 작성 완료 후 esc키 + :wq + Enter키를 눌러 종료한다.
		* 충돌 해결
			* [[Git 병합 충돌]]
		* 병합 완료되면 로컬에서 테스트 진행해보기
		* 객체 생성 제어를 위해서 @NoArgsConstructor(access = AccessLevel.PROTECTED) 로 설정
		* 일관성 문제로 @Setter 제거
		* 오 feature/#8 완성! 
		* 이제 PR 해보기
* onetoone 편의메서드 공부하기
* ERD도 좀 더 깔끔하게 수정해놓고 싶다...


<span style="background:#fff88f">2024-01-13</span>
* PR에 수정 요청 리뷰가 달렸다.
	* 이 경우 수정 요청사항이 반영된 수정본을 commit & push 하면, PR 리뷰어에게 자동적으로 알림이 가고 PR한 브랜치도 알아서 업데이트 된다. PR 수정 요청한 리뷰어가 새로 커밋한 버전의 소스코드를 보고 다시 승인을 해주면 그때 merge가 가능해진다.

<span style="background:#fff88f">2024-01-15</span>
* optional 객체를 사용하여 코드를 작성하는 것을 협의했다.
* 이제 API를 작성해볼 시간!
	* <span style="background:rgba(240, 107, 5, 0.2)">API 유형에도 여러가지가 있는듯? RESTful 사용할 거긴 한데 GraphQL에 대해서도 알아보고 싶다.</span>
	* CQRS 패턴
		* 나는 이제껏 Service 하나만 써왔는데, 어떤 팀원은 QueryService, 어떤 팀원은 CommmandService로 push 해뒀길래 궁금해져서 검색해봤다.
		* https://junuuu.tistory.com/891
		* 서비스 클래스의 역할을 명확히 구분하기 위해 사용한다. 위의 두 명칭은 단순 이름의 차이가 아니라 기능적으로 다른 책임을 나타낸다.
		* QueryService
			* 데이터를 조회하는 작업을 담당하는 서비스 클래스
			* 데이터베이스나 외부 API에서 데이터를 읽어오는 작업만 수행한다.
			* 시스템 상태를 변경하지 않는다. (읽기 전용)
			* 주로 성능 최적화를 위해 캐싱이나 복잡한 조회 로직을 처리한다.
		* CommandService
			* 데이터를 생성, 수정, 삭제하는 작업을 담당하는 서비스 클래스
			* 시스템 상태를 변경하는 작업을 수행한다. (쓰기 작업)
			* 트랜잭션 관리가 중요하고, 주로 비즈니스 로직을 포함한다.
		* 장점
			* 책임이 분리되어 코드가 더 명확해진다
			* 최적화를 위해 읽기와 쓰기에 서로 다른 데이터모델이나 데이터베이스를 사용할 수 있다.
	* controller에서의 Swagger @Operation 설정
		* summary만 적을지, description까지 추가할지
		* description 형식 통일할지?
	* DTO
		* @NotBlank랑 @NotEmpty
			* @NotEmpty: 문자열이 `null`이 아니고, 길이가 0보다 큰 경우에만 유효(공백 문자열 유효)
			* @NotBlank: 문자열이 `null`이 아니고, 길이가 0보다 크며, 공백이 아닌 경우에만 유효
				* 근데! 얘는 문자열에만 쓸 수 있다. 그래서 좋아하는 아이돌 선택 API 리스트에 썼더니
				* jakarta.validation.UnexpectedTypeException: HV000030: No validator could be found for constraint 'jakarta.validation.constraints.NotBlank' validating type 'java.util.List<java.lang.Long>'. Check configuration for 'idolCategoryIds'
				* 에러가 뜸
				* @NotEmpty  + @Size 조합으로 해결

	* Impl는 인터페이스의 구현체!
		* <span style="background:rgba(240, 107, 5, 0.2)">service를 인터페이스와 그 구현체로 나누는 이유는?</span>
	* service 단에서 repo 끌어올 때, @Autowired 쓰기? 
		* 지양하는 추세인듯
		* 사용하면 순환 참조가 일어날 수도 있고, final 붙일 수 없어서 객체 변경이 가능해진다.
		* @Autowired는 클래스의 종속성을 자동으로 연결한다. 이는 아주 편리한 기능이지만 해당 종속성과 밀접하게 연결되어 있음을 의미하기도 한다. 이로인해 코드의 유연성이 떨어지고 장기적인 유지 관리가 더 어려워질 수 있다.
		* https://velog.io/@joypeb/Java-Autowired를-지양하는-이유
* 테스트
	* 패키지는 어떻게? 구현 코드의 패키지 코드와 동일하게
		* https://velog.io/@turtledev/테스트-코드-작성-가이드

* 우왓 하나 완성!! test코드 쓰는 거 엄청나게 재밌다!

* 게시글 선호하는 행사/지뢰 선택 API 관련
	* 반드시 선택해야 하는 건지?
	* 아니라면 화면에 건너뛰기 버튼 필요할듯

* 서비스단에서 사용한 @Transactional
	* 트랜잭션 관리를 선언적으로 수행하기 위해 사용된다
	* 특정 메서드 또는 클래스에 대해 데이터베이스 트랜잭션의 경계를 설정할 수 있다.
	* 해당 어노테이션이 적용된 메서드에서 RuntimeException이 발생하면, 그 트랜잭션에서 수행된 모든 변경이 자동으로 롤백된다.
	
* 마이너한 건데, 다들 List 변수명 어떻게 하는지?
	* 복수형?
	* 엔티티+List?
	* 나는 속성이면 복수형, 엔티티면 뒤에 List 붙임

* 지뢰 선택 API 관련
	* 키워드 갯수 제한 걸지?
	* 동일한 키워드 들어오면 에러 발생시켜야함

* RequestDto에 @Data 어노테이션 붙일지?

* https://velog.io/@balparang/deleteAll-보다-deleteAllInBatch를-사용하자
	* 검토해보기


* 서비스단에서 회원조회는 계속하게되는데, 이거 메서드를 따로 만드는게 좋을지? 어노테이션만드는 건가?


* 새 객체 생성
	* new MemberRequestDto.SelectEventsDto(); 이거는 package private해서 package 넘어가면 쓰기 힘듦
	* builder는 가능

* 패키지 구조에 대한 생각해볼만한 글
	https://youngsuk-dev.tistory.com/21


<span style="background:#fff88f">2024-01-16</span>
* 어제 덕질하는 아이돌 선택, 관심 있는 행사 종류 선택, 지뢰 설정 API 까지 완성했다.
	* 셋 다 로직 자첸 비슷해서 어렵진 않았음
* 오늘은 프로필 사진 설정, 자기소개 문구 설정 API 짤 차례

* 프로필 사진 설정 API
	* https://programmer-ririhan.tistory.com/319
	* 가장 최근에 들어온 사진 객체가 들어오는 걸로? -> 별도의 속성을 할당할 필요는 없어보인다. 아닌가? 생각해보기
	* 프로필 사진 비공개 기능 만들건지?(나만 볼 수 있고 타인은 볼 수 없음)
	* MemberCommandServiceImpl 의 selectMemberProfileImage 메서드
		* <span style="background:#affad1"> 기본 프로필 사진 URL 추후 설정해야 함!</span>
	* <span style="background:#affad1">URL 형식이 올바르지 않은 경우의 예외 처리 추가해야 함</span>

* 지뢰 설정 API 서비스명
	* <span style="background:#affad1">select 말고 create로 바꿔야할듯...</span>


* 자기소개 문구 설정 API 
	* 이거는 notBlank로 할건지??
	* 정하는것에 따라 로직 좀 달라짐
	* 일단은 notBlank로 설정
	* 객체 복사 메서드? converter에 update하기위해

* 테스트
	* 테스트환경의 다른 점
	    - `Mock` 객체를 사용하는 테스트 환경에서는 `save()` 메서드가 명시적으로 반환값을 설정하지 않으면 `null`을 반환한다. 예를 들어, 아래와 같이 `when(memberProfileImageRepository.save(...)).thenReturn(...)`으로 반환값을 설정하지 않았을 경우 문제가 발생할 수 있다.
	    - 메서드를 통해 생성될 객체도 미리 Mock 객체로 만들어둬야 한다.
	    - 
	* 테스트케이스에 `@DisplayName("프로필 이미지를 설정하지 않은 경우 기본 이미지 URL 사용")` 붙이는 게 좋을까?
	* 여러 메서드 테스트하다보니 클래스 길어짐
		* 나누는 게 좋을 거 같음
		1. **테스트 클래스 파일 분리**: 메서드 단위로 테스트 클래스를 나누기.
			* 테스트 클래스는 단일 책임 원칙(Single Responsibility Principle)을 따르게 된다.
		2. **테스트 유틸리티 클래스 도입**: Mock 데이터 생성 및 공통 로직을 분리.
		3. **테스트 클래스 내 그룹화**: `@Nested`를 활용하여 논리적 그룹화.
		4. **단위 테스트와 통합 테스트 분리**: 단위 테스트와 통합 테스트를 별도로 작성.


<span style="background:#fff88f">2024-01-18</span>
* merge한 기존 브랜치들이 없어졌는데 어떻게 한 거지
	* Pull request successfully merged and closed 되면, 브랜치를 안전하게 지울 수 있게 된다.
	* merge한 후에는 브랜치 관리를 위해서 작업이 완료된 브랜치는 삭제해주는 것이 좋다.

<span style="background:#fff88f">2024-01-19</span>
* 에러 관리를 워크북 7주차처럼 ErrorStatus enum으로 하는 게 좋겠다는 리뷰를 받았다! 수정해보잣
	* 이게 왜 더 좋을까?
		* 모든 에러 타입을 enum으로 정의함으로써 코드 전반에 일관된 에러 처리 방식을 유지할 수 있다.
		* 새로운 에러 타입 추가 또는 기존 에러 타입 수정 시 enum만 수정하면 되어서 유지보수가 쉽다
		* 에러 코드가 의미 있는 이름으로 정의되기 때문에 코드 가독성이 향상된다
		* TypeScript와 같은 정적 타이핑 언어를 사용할 경우, enum을 사용하여 타입 안정성을 높일 수 있다
		* 단 초기 설정이 필요하고, 작은 프로젝트에서는 오히려 복잡해지기만 할 수도 있다.
		* 결론: 프로젝트 규모가 크고 복잡한 경우, errorStatus enum을 사용하는 것이 더 유리하다. (일관성, 가독성, 유지보수 측면에서)

<span style="background:#fff88f">2024-01-20</span>
```
// 지뢰 내용을 가져온다  
List<String> landmineContents = request.getLandmineContents();  
// 지뢰 내용을 검증하여 중복된 키워드가 있는지 체크하고, 있다면 에러 발생  
Set<String> uniqueContents = new HashSet<>();  
for (String content : landmineContents) {  
    if (!uniqueContents.add(content)) {  
        throw new TempHandler(ErrorStatus.DUPLICATE_LANDMINE);  
    }  
}
```
* 여기서 DUPLICATE_LANDMINE의 message에 content를 덧붙이고 싶은데 방법을 모르겠다...ㅠㅠ 나중에 찾아보기! 일단은 그냥 중복된 키워드가 존재한다는 정도만 적어두었다.
* 테스트코드도 이에 따라 수정하였다. 
	* https://thisisprogrammingworld.tistory.com/160
		* assertThrows를 사용하였다.
	* Postman 테스트 잘 됨!
		![[스크린샷 2025-01-20 오후 7.14.34.png]]
* 잉 푸시하려는데 로컬 브랜치와 원격 브랜치가 서로 다른 커밋을 가지고 있어 병합 과정이 필요했다.
	1. `git config pull.rebase false`로 병합 방법 설정.
		* Merge로 설정
	2. `git pull origin feature/#11`로 병합 시도.
	3. 충돌이 발생하면 해결하고, `git add`로 스테이징.
	4. `git commit`으로 병합 커밋 생성.
	5. `git push`로 원격 브랜치에 푸시.

<span style="background:#fff88f">2024-01-21</span>
* Handler 패키지 고민
	* nvalid_..category랑 duplicate_landmine 핸들링을 어디서 하는 게 좋을까? member에서 하는 게 좋을까, 아니면 각각의 핸들러를 만드는 게 좋을까? landmineHandler, idolcategoryHandler처럼...
		* 코드의 재사용성을 위하여 전부 분리

* API를 마저 작성해보자
	* [[CRUD API 작성기]]

* PR 리뷰를 해보자
	* https://gyunny.tistory.com/65#4.%20코드%20리뷰를%20할%20때%20주의할%20점-1*\
	* 로그인&회원가입 API 리뷰를 맡았다.
		* [[로그인&회원가입 API 코드 리뷰]]
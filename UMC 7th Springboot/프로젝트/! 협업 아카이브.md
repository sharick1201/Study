* 협업 규칙 설정
	* 브랜치 전략
	* 코드 컨벤션
	* PR 규칙
	* 패키지 전략
	Git 공부... 더 이상 미룰 수 없다


2024-01-09
* 팀원 분이 생성하고 초대해주신 Git Organization에서 백엔드 repository를 내 로컬로 clone해왔다.

2024-01-11
* API 명세서 작성
* 이슈 생성
* 브랜치 생성
	* 나는 entity 작성 반을 맡아 feature/#2 브랜치를 파서 작성 중에 있다. 이때 commit의 주기를 어떻게 하는 게 좋을까?
		* commit은 최대한 잘게 쪼개어 최대한 자주 올리는 게 좋다고들 한다.
			* https://velog.io/@awfjol2008/Git-커밋-단위-및-주기에-관한-고민
		* 유의미한 커밋을 만들어 내는 것은 좋지만, 그것보다 내가 작업한 결과물을 동료들에게 빠르게 공유하는 것이 훨씬 중요하다고 한다. (이유: 충돌 최소화)
			* https://bbbicb.tistory.com/70
	* feature/#2 entity 작성
		* @Id는 자동으로 유일성을 보장해준다. 따라서 @Column(unique = true) 작성할 필요 없음
		* member
			* gender 타입에 대한 고민...
			* 신원이 중요하니 birth는 notNull
			* ~~소개글 타입: varchar로 제안. text 타입은 저장 공간이 다르다보니 느릴 수 있음. 소개글이 500자를 넘길 것 같지는 않다. ->~~ 이렇게 수정하는 걸로 픽스!
			* member_profile_image 매핑
				* orphanRemoval = true 옵션
					* 부모 엔티티에서 자식 엔티티가 제거되었을 때 해당 자식 엔티티를 데이터베이스에서 자동으로 삭제하도록 설정하는 기능
					* `profileImages` 리스트에서 특정 프로필 이미지를 제거하면, 그 프로필 이미지가 데이터베이스에서도 삭제되는 로직
		* member_profile_image
			* memberImage는 notNull
			* ~~회원 프로필 이미지를 단 하나만 조회할 수 있다면, 예전 프로필 사진은 아예 볼 수 없는 건지?~~
			* ~~프로필 이미지를 설정하지 않는다면, 기본 프로필 이미지가 설정된다. 그렇다면 1to1이 되어야 하는 게 맞는 듯~~
			* 회원 프로필 여러 개 볼 수 있는 것으로 PM과 카톡 협의.
		* ~~imageURL 속성의 varchar 길이를 통일해야 할 거 같다. eventCategory에는 1024로, profileImage에는 225로 되어 있음. ->~~ 1024로 통일하기로 서우님과 0112 카톡 협의.
		* Auth_provider
			* provider 속성 enum으로 하는 게 맞나?
		* MateRelationship
			* application_id 요거는 1대1 관계?
			* firstMember, secondMember 중복 방지 로직 고민
		* 양방향 편의 메서드
			* 어디에 작성해야 하는가?
				* https://studyandwrite.tistory.com/535
			* 기존 관계 제거 로직이 필요한 이유
				1. 데이터 무결성 유지:두 엔티티 간의 관계가 변경될 때, 이전 관계를 제거하지 않으면 데이터베이스에 불필요한 연결이 남게 된다. 예를 들어, `Bookmark`가 새로운 `Post`에 연결되면, 이전 `Post`에 대한 연결을 제거해야 한다.
				2. 양방향 관계 일관성: 양방향 관계에서 한쪽만 업데이트하면 일관성이 깨질 수 있다. 예를 들어, `Bookmark`가 새로운 `Post`에 연결되었을 때, 이전 `Post`의 `bookmarkList`에는 여전히 해당 `Bookmark`가 남아 있게 된다. 이를 방지하기 위해 기존 관계를 제거하는 로직이 필요하다.
				3. 메모리 누수 방지: 불필요한 객체 참조가 남아 있으면, 가비지 컬렉터가 해당 객체를 수거하지 못해 메모리 누수가 발생할 수 있다. 기존 관계를 제거함으로써 이러한 문제를 예방할 수 있다.
			* 내일 일어나면 manyToOne에 널러블 설정 확인!
	* 커밋 메세지 수정
		* https://shape-coding.tistory.com/entry/Git-Git-커밋-메시지-수정하는-방법-Change-Commit-Message

2024-01-12
* git push
	* Feature/#2 완성! (연관관계 편의 메서드 제외 상태)
	* 현재 브랜치 확인
	* 원격 저장소 연결 확인
	* 로컬 브랜치를 원격 저장소에 푸시 `git push -u origin feature/#2`
		*  `-u` 옵션은 `feature/#2` 브랜치를 원격 저장소의 `feature/#2` 브랜치와 연결(tracking)한다. 이후에는 `git push`만 입력해도 푸시할 수 있다.
	* 푸시 성공 메세지 확인 `branch 'feature/#2' set up to track 'origin/feature/#2'.`
* 이미지 속성들 varchar(1024)로 통일하기로 결정. 
* 서우님과 함께 TDD를 해보려고 하는데, Entity에서부터 시작하는지? 알아보기
	* https://velog.io/@nimoh/Spring-TDDTest-Driven-Development-시도해보기
	* https://ryuks.tistory.com/9
	* https://www.inflearn.com/community/questions/1412330/tdd-를-적용하면-구현하려는-기능에-필요한-객체들을-설계하고-들어가야-하는건가요?srsltid=AfmBOoouxVqaUjlDrR4tX7CChLBIsUL1tK5SZne4gp6ZfHQBpKbXkmv6
	* input과 output이 있는 repository부터 시작하는 게 일반적인듯.
	* 본격적으로 좀 해보려면 공부가 필요해보인다.
	
* 이제 서우님과 함께 반반씩 적은 entity를 통합하여 테스트해보려고 한다. 이 경우 브랜치를 어떤 식으로 해나가는게 좋을지?
	* 새로운 Feature 브랜치를 파고, 여기다가 기존 두 브랜치를 merge하는 편이 develop 브랜치의 안정성을 유지시킬 수 있으니 해당 방식으로 진행한다.
		* 새로운 통합 브랜치 생성
			develop 브랜치로 이동
			$ git checkout develop
			통합용 브랜치 생성
			$ git checkout -b feature/#8

		* 각 feature 브랜치를 통합 브랜치에 병합
			feature/#1 병합
			$ git merge --no-ff feature/#1
			feature/#2 병합
			$ git merge --no-ff feature/#2
			* merge: feature/#1 - not something we can merge라고 뜨길래 뭐지,,, 했는데 내가 그냥 feature/#1을 로컬에 체크아웃하지 않은 것이었다...!

		* 커밋 메세지 작성
			* vim이 열리면, 키보드에서 i를 눌러 insert mode로 전환한 후 작성한다.
			* 작성 완료 후 esc키 + :wq + Enter키를 눌러 종료한다.
		* 충돌 해결
			* [[Git 병합 충돌]]
		* 병합 완료되면 로컬에서 테스트 진행해보기
		* 객체 생성 제어를 위해서 @NoArgsConstructor(access = AccessLevel.PROTECTED) 로 설정
		* 일관성 문제로 @Setter 제거
		* 오 feature/#8 완성! 
		* 이제 PR 해보기
* onetoone 편의메서드 공부하기
* ERD도 좀 더 깔끔하게 수정해놓고 싶다...


2024-01-13
* PR에 수정 요청 리뷰가 달렸다.
	* 이 경우 수정 요청사항이 반영된 수정본을 commit & push 하면, PR 리뷰어에게 자동적으로 알림이 가고 PR한 브랜치도 알아서 업데이트 된다. PR 수정 요청한 리뷰어가 새로 커밋한 버전의 소스코드를 보고 다시 승인을 해주면 그때 merge가 가능해진다.

2024-01-15
* optional 객체를 사용하여 코드를 작성하는 것을 협의했다.
* 이제 API를 작성해볼 시간!
	* <span style="background:rgba(240, 107, 5, 0.2)">API 유형에도 여러가지가 있는듯? RESTful 사용할 거긴 한데 GraphQL에 대해서도 알아보고 싶다.</span>
	* CQRS 패턴
		* 나는 이제껏 Service 하나만 써왔는데, 어떤 팀원은 QueryService, 어떤 팀원은 CommmandService로 push 해뒀길래 궁금해져서 검색해봤다.
		* https://junuuu.tistory.com/891
		* 서비스 클래스의 역할을 명확히 구분하기 위해 사용한다. 위의 두 명칭은 단순 이름의 차이가 아니라 기능적으로 다른 책임을 나타낸다.
		* QueryService
			* 데이터를 조회하는 작업을 담당하는 서비스 클래스
			* 데이터베이스나 외부 API에서 데이터를 읽어오는 작업만 수행한다.
			* 시스템 상태를 변경하지 않는다. (읽기 전용)
			* 주로 성능 최적화를 위해 캐싱이나 복잡한 조회 로직을 처리한다.
		* CommandService
			* 데이터를 생성, 수정, 삭제하는 작업을 담당하는 서비스 클래스
			* 시스템 상태를 변경하는 작업을 수행한다. (쓰기 작업)
			* 트랜잭션 관리가 중요하고, 주로 비즈니스 로직을 포함한다.
		* 장점
			* 책임이 분리되어 코드가 더 명확해진다
			* 최적화를 위해 읽기와 쓰기에 서로 다른 데이터모델이나 데이터베이스를 사용할 수 있다.
	* controller에서의 Swagger @Operation 설정
		* summary만 적을지, description까지 추가할지
		* description 형식 통일할지?
	* DTO
		* @NotBlank랑 @NotEmpty
			* @NotEmpty: 문자열이 `null`이 아니고, 길이가 0보다 큰 경우에만 유효(공백 문자열 유효)
			* @NotBlank: 문자열이 `null`이 아니고, 길이가 0보다 크며, 공백이 아닌 경우에만 유효
				* 근데! 얘는 문자열에만 쓸 수 있다. 그래서 좋아하는 아이돌 선택 API 리스트에 썼더니
				* jakarta.validation.UnexpectedTypeException: HV000030: No validator could be found for constraint 'jakarta.validation.constraints.NotBlank' validating type 'java.util.List<java.lang.Long>'. Check configuration for 'idolCategoryIds'
				* 에러가 뜸
				* @NotEmpty  + @Size 조합으로 해결

	* Impl는 인터페이스의 구현체!
		* <span style="background:rgba(240, 107, 5, 0.2)">service를 인터페이스와 그 구현체로 나누는 이유는?</span>
	* service 단에서 repo 끌어올 때, @Autowired 쓰기? 
		* 지양하는 추세인듯
		* 사용하면 순환 참조가 일어날 수도 있고, final 붙일 수 없어서 객체 변경이 가능해진다.
		* @Autowired는 클래스의 종속성을 자동으로 연결한다. 이는 아주 편리한 기능이지만 해당 종속성과 밀접하게 연결되어 있음을 의미하기도 한다. 이로인해 코드의 유연성이 떨어지고 장기적인 유지 관리가 더 어려워질 수 있다.
		* https://velog.io/@joypeb/Java-Autowired를-지양하는-이유
* 테스트
	* 패키지는 어떻게? 구현 코드의 패키지 코드와 동일하게
		* https://velog.io/@turtledev/테스트-코드-작성-가이드

* 우왓 하나 완성!! test코드 쓰는 거 엄청나게 재밌다!

* 게시글 선호하는 행사/지뢰 선택 API 관련
	* 반드시 선택해야 하는 건지?
	* 아니라면 화면에 건너뛰기 버튼 필요할듯

* 서비스단에서 사용한 @Transactional
	* 트랜잭션 관리를 선언적으로 수행하기 위해 사용된다
	* 특정 메서드 또는 클래스에 대해 데이터베이스 트랜잭션의 경계를 설정할 수 있다.
	* 해당 어노테이션이 적용된 메서드에서 RuntimeException이 발생하면, 그 트랜잭션에서 수행된 모든 변경이 자동으로 롤백된다.
	
* 마이너한 건데, 다들 List 변수명 어떻게 하는지?
	* 복수형?
	* 엔티티+List?
	* 나는 속성이면 복수형, 엔티티면 뒤에 List 붙임

* 지뢰 선택 API 관련
	* 키워드 갯수 제한 걸지?
	* 동일한 키워드 들어오면 에러 발생시켜야함

* RequestDto에 @Data 어노테이션 붙일지?

* https://velog.io/@balparang/deleteAll-보다-deleteAllInBatch를-사용하자
	* 검토해보기


* 서비스단에서 회원조회는 계속하게되는데, 이거 메서드를 따로 만드는게 좋을지? 어노테이션만드는 건가?


* 새 객체 생성
	* new MemberRequestDto.SelectEventsDto(); 이거는 package private해서 package 넘어가면 쓰기 힘듦
	* builder는 가능

* 패키지 구조에 대한 생각해볼만한 글
	https://youngsuk-dev.tistory.com/21
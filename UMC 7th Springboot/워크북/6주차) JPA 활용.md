##### 목표
* 즉시 로딩과 지연 로딩의 전략 차이에 대해 알아보고, 지연 로딩을 채택하는 이유에 대해 이해한다.
* JPQL과 QueryDSL의 차이에 대해 이해한다.

##### 내용 키워드
* JPA의 영속성 컨텍스트
* 지연 로딩과 즉시 로딩
* N+1 문제
* JPQL
* QueryDSL

#### 내용 정리
* 영속성 컨텍스트(Persistance Context)
	* 영속성 컨텍스트란?
		* 데이터(엔티티 객체)를 영구적으로 저장하는 일종의 메모리 공간이다.
		* 일종의 캐시 메모리이다.
			* DB 속 데이터 조회 시, 먼저 캐시에 찾는 데이터가 남아 있는지 확인한다. 캐시에 남아있는 데이터라면 DB까지 가지 않고 그걸 들고가고, 캐시에 없다면 DB에서 가져온다.
		* 최초로 엔티티에 접근하면, DB에서 끌어온 엔티티를 영속성 컨텍스트에 등록한다. 이후 JPA에서 Repository 인터페이스를 통하여 같은 엔티티에 접근하면, DB가 아니라 영속성 컨텍스트에 있는 데이터를 조회하게 된다.
		* 쉽게 말해, 애플리케이션과 데이터베이스 사이에서 데이터를 저장하는 가상의 데이터베이스 역할을 한다.
		* @EntityManager를 이용하여 접근한다.
		
	* 왜 영속해야 하는가?
		* 1차적인 캐시 기능을 해준다.
		* 변경 감지(Dirty Checking)를 해줄 수 있다.
			* 트랜잭션이 끝나면, JPA는 영속성 컨텍스트 내부에서 변경된 내용을 자동으로 감지한다. 또한 DB에 UPDATE 쿼리를 날려 변경된 내용을 반영한다.
		* 지연 로딩(Lazy Loading)이 가능해진다.
			* 5주차에서 언급만 하고 넘어간 FetchType.LAZY가 바로 지연 로딩에 대한 부분이다.
			* vs. 즉시 로딩(FetchType.EAGER)
				* Member 엔티티에 Address 엔티티, 장바구니 엔티티가 매핑되어 있다고 해보자.
				* 즉시 로딩은 Member, Address, 장바구니 모두를 실제 DB에서 즉시 한 번에 조회하여, 하나의 쿼리로 가져온다.
				* 지연 로딩은 Member, Address, 장바구니 조회를 분리하여... Member는 DB 조회를, Address, 장바구니는 프록시에서 조회해온다. 즉, 매핑된 테이블에 대한 정보는 DB가 아닌 프록시에서 데이터를 가져온다.

### 실습


##### 작업 상태



##### 느낀 점, 추가로 더 공부한 것, 더 공부해보고 싶은 것





###### 참고자료
##### 목표
* 즉시 로딩과 지연 로딩의 전략 차이에 대해 알아보고, 지연 로딩을 채택하는 이유에 대해 이해한다.
* JPQL과 QueryDSL의 차이에 대해 이해한다.

##### 내용 키워드
* JPA의 영속성 컨텍스트
* 지연 로딩과 즉시 로딩
* N+1 문제
* JPQL
* QueryDSL

#### 내용 정리
* 영속성 컨텍스트(Persistance Context)
	* 영속성 컨텍스트란?
		* 데이터(엔티티 객체)를 영구적으로 저장하는 일종의 메모리 공간이다.
		* 일종의 캐시 메모리이다.
			* DB 속 데이터 조회 시, 먼저 캐시에 찾는 데이터가 남아 있는지 확인한다. 캐시에 남아있는 데이터라면 DB까지 가지 않고 그걸 들고가고, 캐시에 없다면 DB에서 가져온다.
		* 최초로 엔티티에 접근하면, DB에서 끌어온 엔티티를 영속성 컨텍스트에 등록한다. 이후 JPA에서 Repository 인터페이스를 통하여 같은 엔티티에 접근하면, DB가 아니라 영속성 컨텍스트에 있는 데이터를 조회하게 된다.
		* 쉽게 말해, 애플리케이션과 데이터베이스 사이에서 데이터를 저장하는 가상의 데이터베이스 역할을 한다.
		* @EntityManager를 이용하여 접근한다.
		
	* 왜 영속해야 하는가?
		* 1차적인 캐시 기능을 해준다.
		* 변경 감지(Dirty Checking)를 해줄 수 있다.
			* 트랜잭션이 끝나면, JPA는 영속성 컨텍스트 내부에서 변경된 내용을 자동으로 감지한다. 또한 DB에 UPDATE 쿼리를 날려 변경된 내용을 반영한다.
		* 지연 로딩(Lazy Loading)이 가능해진다.
			* 5주차에서 언급만 하고 넘어간 FetchType.LAZY가 바로 지연 로딩에 대한 부분이다.
			* vs. 즉시 로딩(FetchType.EAGER)
				* Member 엔티티에 Address 엔티티, 장바구니 엔티티가 매핑되어 있다고 해보자.
				* 즉시 로딩은 Member, Address, 장바구니 모두를 실제 DB에서 즉시 한 번에 조회하여, 하나의 쿼리로 가져온다. 즉, 관련된 엔티티를 한 번의 쿼리로 즉시 조회한다.
				* 지연 로딩은 Member, Address, 장바구니 조회를 분리하여... Member만 조회하는 쿼리만 DB로 날린다. Address, 장바구니는 프록시 객체로 생성해둔다. 후에 Address, 장바구니 객체가 사용될 때 그제서야 DB에서 Address, 장바구니 정보를 가져와 프록시 객체를 초기화시킨다.
					* 여기서의 프록시란?
						* 대리, 중계인 역할
						* 특정 개체 호출 시, 프록시 개체를 중간에 두면 이 프록시 객체가 진짜 객체 대신 요청을 받는다.
						* 프록시 객체는 실제 객체를 상속받는다.
						* 처음 사용될 때 한 번만 초기화된다.
			* `@ManyToOne, @OneToOne`의 디폴트: 즉시 로딩
			* `@OneToMany, @ManyToMany`의 디폴트: 지연 로딩
			* 가급적이면 지연 로딩을 사용할 것이 권장된다. 즉시 로딩은 JPQL에서 N+1문제가 발생할 수 있기 때문이다.
			
* N+1 문제
	* 1개의 쿼리를 실행한 후에, 관련된 n개의 데이터를 각각 가져오기 위해 추가적으로 N번의 불필요한 쿼리가 실행되는 문제
	* 성능 저하를 발생시킴
	* RDB와 객체 지향 패러다임 사이의 간극으로 인해 발생하는 문제
	* https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1
		* FetchType.LAZY여도 발생이 가능하다. 연관 관계로 매핑된 객체가 사용될 때 DB에서 정보를 가져오는 것은 동일하기 때문. 발생 시점의 차이가 되겠다.

### 실습


##### 작업 상태



##### 느낀 점, 추가로 더 공부한 것, 더 공부해보고 싶은 것





###### 참고자료
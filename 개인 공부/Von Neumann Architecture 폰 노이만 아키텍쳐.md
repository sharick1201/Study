= 폰 노이만 구조, 폰 노이만 원리(원칙)

* 컴퓨터 시스템의 기본 구조를 설명하는 개념
* 하드웨어와 소프트웨어의 상호작용 방식 정의
* 인간 사고의 과정을 참고하여 설계
* <font color="#c0504d">한 마디로 설명하면, <u>프로그램과 데이터를 동일한 메모리에 저장하고 순차적으로 처리</u>하는 컴퓨터 아키텍쳐 구조</font>

#### 구성 요소
![[스크린샷 2025-03-15 오후 4.42.47.png| 출처: 과기부 블로그 https://m.blog.naver.com/with_msip/221981730449]]	

1. 메모리
	* 프로그램과 데이터 영역에는 물리적 구분이 없기 때문에 명령어와 데이터가 같은 메모리, 버스를 사용하게 된다. (CPU가 명령어와 데이터에 동시 접속할 수 없다.)
2. CPU
3. 프로그램
*  입력장치 (마우스, 키보드 등)
*  출력장치 (프린터, 모니터 등)
*  Bus: CPU와 메모리는 서로 분리되어 있으므로 둘을 연결하는 구성품이 필요하다. 그것이 바로 Bus



<font color="#9bbb59">OS도 이 구조를 바탕으로 설명된다. 거의 모든 컴퓨터가 이 구조를 기반으로 한다고 한다. 그러면 다른 구조에는 어떤 게 있을까? 그리고 왜 이게 압도적으로 major한 아키텍쳐가 되었을까?</font>

#### 장점: 프로그램 내장 방식 컴퓨터

* 이전에는 각 명령과 데이터에 해당하는 하드웨어에 직접 전선을 바꿔 끼워 입력했다. 폰 노이만 구조는 명령(기능)들을 담은 소프트웨어를 메모리 안에 내장시켰기 때문에, 물리적으로 뭔가 개입할 필요가 없다. 계산할 때마다 메모리 내의 프로그램 및 데이터를 CPU에 전달하기만 하면 되기 때문이다.

→ 다른 일을 하고싶을 때, 소프트웨어만 갈아끼우면 되기 때문에 여러 기능을 간단하게 사용할 수 있게 되었다. 범용성이 매우 커졌다. 이게 거의 모든 컴퓨터가 폰 노이만 구조를 따르는 이유
			
			
#### 단점 1: 폰 노이만 병목현상
* 계산 속도가 메모리 속도에 영향을 미친다.

* 메모리에서 데이터나 프로그램을 CPU에 불러와야 계산을 시작할 수 있기 때문에, 메모리에서 불러오는 속도가 느리면 전체 기능 속도도 떨어진다.

* 또한 프로그램과 데이터 영역에는 물리적 구분이 없기 때문에 명령어와 데이터가 같은 메모리, 버스를 사용하게 된다. (CPU가 명령어와 데이터에 동시 접속할 수 없다.)
				
#### 단점 2:CPU가 비효율적으로 사용된다.
* 한 번에 하나의 명령어만 순차적으로 처리하기 때문이다.
* 수치계산, 정밀한 프로그램 실행에서는 딱히 단점은 아니지만, 이미지 및 소리와 같은 아날로그 데이터 처리에는 좀 비효율적이다.




#### 폰 노이만 구조의 단점을 보완한 아키텍쳐

* 단점 1, 폰 노이만 병목현상을 극복하기 위해 나온 아키텍쳐
	* 하버드 구조
		* 명령어와 데이터가 각각의 버스를 이용한다.
		* CPU가 명령어와 데이터에 동시 접속할 수 있다.
		* 두 개의 메모리가 필요하므로 CPU 코어에서 공간을 많이 차지하고, 더 많은 전기회로가 필요하다.
		* 임베디드 시스템에서 많이 사용됨
		* 현대에는 CPU 외부적으로는 폰 노이만 구조를, 내부적으로는 하버드 구조를 따르는 컴퓨터들이 꽤 등장했다.(속도는 좀 빨라졌지만, 어쨌든 폰 노이만 구조를 따르고 있기 때문에 근본적인 원인의 해결은 아니다.)
			* 운영체제와 소프트웨어(즉, CPU 외부)는 폰 노이만 아키텍쳐에 따라 설계된다.
			* CPU 내부에서는 명령어 캐시와 데이터 캐시를 따로 둔다.![[스크린샷 2025-03-15 오후 6.32.51.png]]


	* 메모리 계층 구조
		* 메모리를 필요에 따라 여러 종류로 나누어 두는 것
		* CPU가 메모리에 더 빨리 접근할 수 있다.
			* 데이터를 저장하는 메모리 용량이 작을수록 더 빨리 접근할 수 있기 때문.
		* 자주 쓰는 데이터와 잘 안 쓰이는 데이터가 있으니 분리하자: 자주 사용하는 데이터는 빠른 메모리에 저장하고, 덜 사용되는 데이터는 느린 메모리에 저장(자주 사용되는 데이터는 그리 많지 않다. )
		* 메모리가 레지스터, 캐시 메모리, RAM, 보조 스토리지 등으로 분리되어 있다는게, 바로 메모리 계층 구조를 따른 것이라는 의미다.
			* 레지스터
				* CPU 내부에 위치
				* 가장 빠름
				* 용량 매우 작음(KB단위)
				* CPU가 즉시 사용할 수 있는 데이터와 명령어 저장
			* 캐시 메모리
				* 시스템 보드 내에서, CPU와 RAM 사이에 위치
				* 레지스터보단 느리지만 매우 빠른 편
				* 용량 작음(KB~MB 사이)
				* 자주 사용되는 데이터와 명령어를 저장
				* L1, L2, L3이 있고, L1이 제일 빠르고 용량이 작다
			* RAM
				* 시스템 보드 어딘가에... 위치
				* 속도 보통
				* 용량 큼(GB)
				* 전원 꺼지면 데이터 휘발됨
			* 스토리지
				* 외부 장치에 위치(HDD, SSD 등)
				* 두 번째로 느림
				* 용량 매우 큼(TB)
				* 전원이 꺼져도 데이터와 프로그램을 영구적으로 저장
			* 네트워크 저장소(클라우드 스토리지)
				* 네트워크를 통해 접근
				* 가장 느림
				* 용량 매우매우 큼
				* 네트워크 대역폭에 따라 성능이 달라진다
			* 위의 리스트에서, 위에서 아래로 내려올수록 느리고, 용량이 커진다.
		* 폰 노이만 구조를 대체하는 게 아니라, 폰 노이만 구조와 함께 쓰임. 다만 병목현상을 줄여주는 역할을 할 뿐
		* 앵간한 곳에 다 사용되는 구조다.
		* <font color="#4f81bd">요즘은 대다수 컴퓨터가 폰 노이만 구조+하버드 구조+메모리 계층 구조를 사용한다고 보면 될 듯?</font>
	
	* NUMA Non-Uniform Memory Access
		* 멀티코어 및 다중 프로세서 시스템에서 성능을 최적화하기 위해 설계
		* 여러 개의 프로세서가 각각 자신만의 로컬 메모리를 가지고 있다. 자신의 로컬 메모리에 대해서는 다른 프로세서의 메모리보다 접근 속도가 더 빠르다.(물리적 거리 때문에)
		* 자신의 로컬 메모리 접근시간과 다른 프로세서의 메모리 접근시간에 차이가 나기 때문에, 비대칭적인 메모리 접근이 된다.
		* 메모리 접근 패턴을 최적화해야 해서 좀 복잡하다. 메모리 관리가 까다롭다.
		* <font color="#4f81bd">가상 머신이 여러 개일 때 유용할 거 같다.</font>
		* 대규모 데이터 관리에서도 꽤 쓰이는 듯
			* https://blog.naver.com/geartec82/220332228939
		
* 단점 2, 비효율적인 CPU 사용을 극복하기 위해 나온 아키텍쳐
	* 한 번에 복수의 명령어를 처리하는 방법들을 고안
		* 명령어 병렬처리
			* CPU가 동시에 여러 개의 명령어를 실행할 수 있게끔 설계
			* 방식
				* pipelining
					* 명령어를 여러 단계로 나누어 각 단계에서 다른 명령어를 동시에 처리
					* ex. 명령어가 실행되는 동안 다음 명령어를 디코딩하고 그 다음 명령어를 가져오는 식
				* speculative execution
					* 프로그램의 실행 흐름을 예측 → 예측된 경로에 따라 명령어를 미리 실행
		* 병렬 컴퓨팅
			* <font color="#4f81bd">이거 자체가 되게 딥한 분야인거같음. 좀 더 구체적으로 공부해보면 좋을 듯.</font>
			* 여러 개의 프로세서가 task를 분담하여 동시에 처리
			* 방식	
				* 대칭형 다중처리 SMP
					* 두 개 이상의 프로세서가 동일한 메모리와 I/O 장치를 공유 + 각각의 프로세서가 독립적으로 작업을 수행할 수 있는 아키텍처
						* <font color="#9bbb59">어떻게 독립적으로 수행하지?</font>
							* 각각 다른 스레드를 실행함으로써.
							* OS에서 메모리 관리 및 스케줄링 해준다.
						* <font color="#9bbb59">데이터 일관성 관리는 어떻게 하지?</font>
							* 동기화 기법을 사용한다.
								* 뮤텍스 Mutex 한 번에 하나의 스레드만 공유 자원에 접근할 수 있도록 제어하는 동기화 객체 (Lock 사용)
								* 세마포어 Semaphore 특정 수의 스레드가 자원에 접근할 수 있도록 제어하는 동기화 객체
								* 좀 더 고수준에는 모니터 등이 있다.
								* <font color="#4f81bd">나중에 좀 더 구체적으로 공부해보고 싶다.</font>
					* 모든 프로세서는 동등한 권한을 가지고, 같은 OS에서 실행된다.
					* 프로세서 간의 통신은 메모리를 통해.
					* NUMA가 여기서 사용된다.
						
				* 대규모 병렬 컴퓨터 MPP
					* 수백에서 수천 개의 프로세서가 서로 독립적으로 작업을 수행할 수 있는 아키텍쳐
					* 각 프로세서는 자체 메모리와 I/O 장치를 지닌다.
					* 프로세서 간의 통신은 네트워크를 통해 이루어지며, 각 프로세서는 독립적으로 실행
					* 대규모 데이터 처리 및 복잡한 계산 수행 시 적합
					* 프로세서 수 늘리는 게 쉽기 때문에 확장성이 좋다.
				
			* LCMP Load-Compute-Memory-Process


	* 병렬처리는 1. 너무 복잡하고 2.모든 문제에 효율적으로 적용되는 것도 아니고 3.병렬 처리를 위한 overhead(시간이 추가적으로 소요)가 발생하고 4. 병렬 컴퓨팅의 경우 비싸기 때문에, 폰 노이만 구조를 완전 대체하기에는 부적절하다
		* <font color="#9bbb59">그럼 어떤 경우에 병렬처리 아키텍쳐들이 아주 효율적으로 작동하는가?</font>
			* 대규모 데이터 처리, 복잡한 시뮬레이션, 기계학습, 영상 처리 및 렌더링, 클라우드 컴퓨팅




##### 참고자료
https://m.blog.naver.com/with_msip/221981730449
https://velog.io/@ckstn0777/컴퓨터-구조
* 폰 노이만 구조 & 하버드 구조

https://ko.wikipedia.org/wiki/메모리_계층_구조
https://velog.io/@yu-jin-song/CS-메모리-계층-구조
* 메모리 계층 구조

https://blog.naver.com/geartec82/220332228939
* NUMA

https://velog.io/@thekim12/병렬처리
* 병렬처리(자세하고 체계적으로 정리되어 있다! 감 잡기 좋은 자료)


https://news.skhynix.co.kr/post/rino-choi-column-6
* 반도체 분야에서, 폰노이만 구조의 속도 한계를 줄이기 위한 물리적 접근(반도체 구성 물질 변경)과 구조적 접근(폰노이만 구조가 아닌 새로운 접근: 뇌 신경망 구조를 흉내낸 뉴로모픽 컴퓨팅), 근본적 접근(디지털 체계를 벗어난 양자 컴퓨팅)을 소개한다.
* 내용에 집어넣진 않았지만, 재밌어서 링크 붙여둠


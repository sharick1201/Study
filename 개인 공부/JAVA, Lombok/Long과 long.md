long countByMemberId(Long memberId);... 작성하다가, Long이 좋을까, long이 좋을까 고민하다 문서 개설

----

`long`과 `Long`은 둘 다 Java에서 정수를 나타내는 데 사용되지만, 기본형(primitive type)과 참조형(wrapper class)이라는 차이가 있다.

####  `long` (기본형)

- **특징**:
    - Java의 기본 데이터 타입(primitive type)으로, 8바이트 크기를 가지며 정수를 저장한다.
    - 값 자체를 메모리에 저장하므로 객체 생성 오버헤드가 없다.
    - 초기값은 `0`입니다.
    - `null` 값을 가질 수 없습니다.
    
- **장점**:
    - **메모리 효율적**: 추가적인 객체 생성 없이 값만 저장하므로 메모리를 덜 사용한다.
    - **빠른 성능**: 객체 생성 및 관리가 필요 없으므로 참조형보다 빠르다
- **단점**:
    - `null`을 표현할 수 없으므로, 값이 없는 상태를 처리할 수 없다.
    - 컬렉션(예: `List`, `Map`)에 직접 사용할 수 없다. (컬렉션은 객체만 저장 가능)


#### `Long` (참조형)

- **특징**:
    - Java의 래퍼 클래스(wrapper class)로, 기본형 `long`을 객체로 감싸는 클래스다.
    - 객체이기 때문에 **`null` 값**을 가질 수 있다.
    - `java.lang.Long` 클래스는 다양한 유틸리티 메서드(e.g., `parseLong`, `compareTo`)를 제공한다.

- **장점**:
    - **`null` 처리 가능**: 값이 없거나 미정인 상태를 표현할 수 있다.
    - **컬렉션에 사용 가능**: `List<Long>`, `Map<Long, Object>` 등 컬렉션에서 사용할 수 있다.
    - 다양한 유틸리티 메서드를 활용할 수 있다.
- **단점**:
    
    - **메모리 비효율적**: 객체를 생성해야 하므로 추가적인 메모리 오버헤드가 발생한다.
    - **성능 저하**: 기본형보다 느립니다. 특히, 반복적으로 연산을 수행할 때 성능 차이가 커질 수 있다.


|**특징**|**`long`**|**`Long`**|
|---|---|---|
|**타입**|기본형(primitive type)|참조형(wrapper class)|
|**메모리**|값만 저장하므로 메모리 효율적|객체를 생성하므로 메모리 사용량 증가|
|**초기값**|`0`|`null`|
|**`null` 허용 여부**|불가능|가능|
|**컬렉션 사용**|불가능|가능|
|**성능**|빠름|느림|

---

#### 언제 무엇을 사용하는 게 좋나?

##### `long`을 사용하는 경우:

1. **성능이 중요한 경우**:
    - 대량의 데이터를 처리하거나 반복적으로 연산을 수행하는 경우
    - 예: 루프에서 카운터로 사용할 때
    `long sum = 0; for (int i = 0; i < 1000000; i++) {     sum += i; }`
    
2. **값이 항상 존재하는 경우**:
    - 값이 `null`일 가능성이 없고, 기본값(`0`)으로 충분히 의미를 표현할 수 있는 경우.

##### `Long`을 사용하는 경우:

1. **값이 없을 가능성이 있는 경우**:
    - 데이터베이스에서 값을 가져오거나, 값이 `null`일 수 있는 상황.
    - 예: 특정 사용자의 게시물 개수가 없을 때 `null`로 처리.
    `Long postCount = null;`
    
2. **컬렉션에 저장해야 하는 경우**:
    - `List`, `Map` 등 컬렉션에 저장해야 하는 경우
    - 예: 특정 사용자들의 게시물 수를 저장하는 경우
    `List<Long> postCounts = Arrays.asList(10L, 20L, null);`
    
3. **객체 지향적인 작업이 필요한 경우**:
    - `Long` 클래스의 유틸리티 메서드를 활용해야 하는 경우
    - 예: 문자열을 숫자로 변환
    `Long number = Long.parseLong("12345");`
    

---
##### 오토박싱과 언박싱

Java는 기본형과 참조형 간의 변환을 자동으로 처리하는 오토박싱(Auto-Boxing)과 언박싱(Unboxing)을 지원한다.

```
Long wrapper = 10L; // 오토박싱: long -> Long
long primitive = wrapper; // 언박싱: Long -> long
```

- 오토박싱과 언박싱은 편하지만, 성능에 영향을 줄 수 있다.
- 반복문에서 오토박싱이 자주 발생하면 성능 저하의 원인이 될 수 있다.

---


- **`long`**:
    - 기본적으로 `long`을 사용하는 것이 좋다.
    - 값이 항상 존재하고, 성능이 중요한 경우 적합
- **`Long`**:
    - 값이 없을 수 있거나, 컬렉션에 저장해야 하는 경우 사용
    - 데이터베이스와 연동하거나, 객체 지향적인 작업이 필요한 경우 적합